// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package main

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// CanWorkABI is the input ABI used to generate the binding from.
const CanWorkABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"emergencyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"cancelJobByProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrow\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"closedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"updatePriceOracleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"completeJob\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_payToClientPercentage\",\"type\":\"uint8\"},{\"name\":\"_payToProviderPercentage\",\"type\":\"uint8\"},{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_payToArbiterPercentage\",\"type\":\"uint8\"}],\"name\":\"cancelJobByAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"getJobPayments\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"valueInDai\",\"type\":\"uint256\"},{\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"name\":\"paidToDappAmount\",\"type\":\"uint256\"},{\"name\":\"paidToProviderAmount\",\"type\":\"uint256\"},{\"name\":\"paidToClientAmount\",\"type\":\"uint256\"},{\"name\":\"paidToArbiterAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"isMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getEmergencyTransferSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"getEmergencyTransferSignersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"},{\"name\":\"_totalCosts\",\"type\":\"uint256\"}],\"name\":\"createJob\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"getJob\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"valueInDai\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"closedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_canworkAdmin\",\"type\":\"address\"},{\"name\":\"_dApp\",\"type\":\"address\"},{\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrowPayments\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"name\":\"paidToDappAmount\",\"type\":\"uint256\"},{\"name\":\"paidToProviderAmount\",\"type\":\"uint256\"},{\"name\":\"paidToClientAmount\",\"type\":\"uint256\"},{\"name\":\"paidToArbiterAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"OnEmeregencyTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalCosts\",\"type\":\"uint256\"}],\"name\":\"OnCreateJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"OnCompleteJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"OnCancelJobByProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"payToProviderPercentage\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payToArbiterPercentage\",\"type\":\"uint8\"}],\"name\":\"OnCancelJobByAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dApp\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceOracle\",\"type\":\"address\"}],\"name\":\"OnInitialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"OnCreateEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCompleteEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrowByProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payToProviderAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payToArbiterAmount\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"Migrated\",\"type\":\"event\"}]"

// CanWorkBin is the compiled bytecode used for deploying new contracts.
const CanWorkBin = `0x6080604052600060025534801561001557600080fd5b506136d7806100256000396000f3006080604052600436106100f05763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416630e50183481146100f55780632630c12f1461012a5780636e6bfca01461015b5780637d19e5961461017357806386d1e02b146101d25780638ad682af146101f5578063991e01391461027f578063a52c7a4f14610297578063afcfad6e146102ce578063c0bac1a81461031e578063d047a0d0146103b5578063d391014b146103fc578063dea90acf14610411578063e7acaa1e14610444578063f729cf0d14610471578063f8c8765e14610489578063fd232b59146104bc575b600080fd5b34801561010157600080fd5b50610116600160a060020a03600435166104d4565b604080519115158252519081900360200190f35b34801561013657600080fd5b5061013f610b46565b60408051600160a060020a039092168252519081900360200190f35b34801561016757600080fd5b50610116600435610b55565b34801561017f57600080fd5b5061018b600435610c46565b60408051600160a060020a03988916815296909716602087015285870194909452606085019290925260ff16608084015260a083015260c082015290519081900360e00190f35b3480156101de57600080fd5b506101f3600160a060020a0360043516610d41565b005b34801561020157600080fd5b5061020a610f47565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561024457818101518382015260200161022c565b50505050905090810190601f1680156102715780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561028b57600080fd5b50610116600435610f7e565b3480156102a357600080fd5b5061011660043560ff602435811690604435811690600160a060020a0360643516906084351661106f565b3480156102da57600080fd5b506102e6600435611365565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b34801561032a57600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261011694369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a99988101979196509182019450925082915084018382808284375094975061147f9650505050505050565b3480156103c157600080fd5b506103d9600160a060020a0360043516602435611548565b60408051600160a060020a03909316835290151560208301528051918290030190f35b34801561040857600080fd5b5061020a6116b9565b34801561041d57600080fd5b50610432600160a060020a03600435166116f0565b60408051918252519081900360200190f35b34801561045057600080fd5b50610116600435600160a060020a0360243581169060443516606435611851565b34801561047d57600080fd5b5061018b60043561197a565b34801561049557600080fd5b506101f3600160a060020a0360043581169060243581169060443581169060643516611a7d565b3480156104c857600080fd5b506102e6600435611d93565b60008080600160a060020a0384161515610538576040805160e560020a62461bcd02815260206004820152601560248201527f41646472657373206d7573742062652076616c69640000000000000000000000604482015290519081900360640190fd5b600754604080518082018252600581527f6f776e65720000000000000000000000000000000000000000000000000000006020820190815282517f217fe6c6000000000000000000000000000000000000000000000000000000008152336004820181815260248301958652845160448401528451600160a060020a039097169663217fe6c6969295949193606401919080838360005b838110156105e75781810151838201526020016105cf565b50505050905090810190601f1680156106145780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b15801561063457600080fd5b505af1158015610648573d6000803e3d6000fd5b505050506040513d602081101561065e57600080fd5b505115156106b6576040805160e560020a62461bcd02815260206004820152601460248201527f4d7573742068617665204f776e657220726f6c65000000000000000000000000604482015290519081900360640190fd5b604080516c01000000000000000000000000308102602080840191909152600160a060020a03881690910260348301527f656d657267656e63795472616e73666572000000000000000000000000000000604883015282516039818403018152605990920192839052815191929182918401908083835b6020831061074c5780518252601f19909201916020918201910161072d565b51815160209384036101000a6000190180199092169116179052604080519290940182900382206007547f46aaf13900000000000000000000000000000000000000000000000000000000845260048401829052945190985060029650600160a060020a0390941694506346aaf139936024808401945091929091908290030181600087803b1580156107de57600080fd5b505af11580156107f2573d6000803e3d6000fd5b505050506040513d602081101561080857600080fd5b505160ff1610156108b657600754604080517fe287adf4000000000000000000000000000000000000000000000000000000008152336004820152602481018590529051600160a060020a039092169163e287adf4916044808201926020929091908290030181600087803b15801561088057600080fd5b505af1158015610894573d6000803e3d6000fd5b505050506040513d60208110156108aa57600080fd5b5060009350610b3f9050565b600754604080517fe287adf4000000000000000000000000000000000000000000000000000000008152336004820152602481018590529051600160a060020a039092169163e287adf4916044808201926020929091908290030181600087803b15801561092357600080fd5b505af1158015610937573d6000803e3d6000fd5b505050506040513d602081101561094d57600080fd5b5050600754604080517f5969c0e1000000000000000000000000000000000000000000000000000000008152600481018590529051600160a060020a0390921691635969c0e1916024808201926020929091908290030181600087803b1580156109b657600080fd5b505af11580156109ca573d6000803e3d6000fd5b505050506040513d60208110156109e057600080fd5b5050600a54604080517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529051600160a060020a03909216916370a08231916024808201926020929091908290030181600087803b158015610a4857600080fd5b505af1158015610a5c573d6000803e3d6000fd5b505050506040513d6020811015610a7257600080fd5b5051600a546040805160e060020a63a9059cbb028152600160a060020a03888116600483015260248201859052915193945091169163a9059cbb916044808201926020929091908290030181600087803b158015610acf57600080fd5b505af1158015610ae3573d6000803e3d6000fd5b505050506040513d6020811015610af957600080fd5b5050604080518281529051600160a060020a038616917fd52f490db8aced6e82c33e39d01bca1886f5e9579c9e3347e8a89d60ad39bb09919081900360200190a2600192505b5050919050565b600554600160a060020a031681565b6000600160f860020a031960f860020a83831a02161515610b7557600080fd5b60008281526008602052604081206004015460ff166002811115610b9557fe5b14610b9f57600080fd5b600082815260086020526040902060020154600160a060020a03163314610bc557600080fd5b600082815260086020526040902060030154610be090611e59565b1515610beb57600080fd5b600082815260086020526040808220600401805460ff1916600217905560095490518492600160a060020a03909216917f9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c42691a3506001919050565b60008060008060008060008088118015610c6f5750600088815260066020819052604082200154115b1515610cc5576040805160e560020a62461bcd02815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b6000888152600660205260409020600181015460028083015460038401546004850154600590950154600160a060020a03948516959290941693909260ff90911690811115610d1057fe5b60009c8d52600660208190526040909d209c8d01546007909d0154949d939c929b5090995097509550909350915050565b600160a060020a03811615801590610d675750600554600160a060020a03828116911614155b1515610dbd576040805160e560020a62461bcd02815260206004820152601a60248201527f4d7573742062652076616c69642c206e65772061646472657373000000000000604482015290519081900360640190fd5b600754604080518082018252600581527f6f776e65720000000000000000000000000000000000000000000000000000006020820190815282517f217fe6c6000000000000000000000000000000000000000000000000000000008152336004820181815260248301958652845160448401528451600160a060020a039097169663217fe6c6969295949193606401919080838360005b83811015610e6c578181015183820152602001610e54565b50505050905090810190601f168015610e995780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b158015610eb957600080fd5b505af1158015610ecd573d6000803e3d6000fd5b505050506040513d6020811015610ee357600080fd5b50511515610f3b576040805160e560020a62461bcd02815260206004820152601560248201527f4f6e6c79206f776e65722063616e207570646174650000000000000000000000604482015290519081900360640190fd5b610f44816120bd565b50565b60408051808201909152600581527f6f776e6572000000000000000000000000000000000000000000000000000000602082015281565b6000600160f860020a031960f860020a83831a02161515610f9e57600080fd5b60008281526008602052604081206004015460ff166002811115610fbe57fe5b14610fc857600080fd5b600082815260086020526040902060010154600160a060020a03163314610fee57600080fd5b600082815260086020526040902060030154611009906120ec565b151561101457600080fd5b600082815260086020526040808220600401805460ff1916600117905560095490518492600160a060020a03909216917f5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a91a3506001919050565b6000600160f860020a031960f860020a87831a021615156110da576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b60008681526008602052604081206004015460ff1660028111156110fa57fe5b1461110457600080fd5b600754604080518082018252600581527f61646d696e0000000000000000000000000000000000000000000000000000006020820190815282517f217fe6c6000000000000000000000000000000000000000000000000000000008152336004820181815260248301958652845160448401528451600160a060020a039097169663217fe6c6969295949193606401919080838360005b838110156111b357818101518382015260200161119b565b50505050905090810190601f1680156111e05780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b15801561120057600080fd5b505af1158015611214573d6000803e3d6000fd5b505050506040513d602081101561122a57600080fd5b5051151561123757600080fd5b600560ff831611156112b9576040805160e560020a62461bcd02815260206004820152602c60248201527f417262697465722063616e6e6f742072656365697665206d6f7265207468616e60448201527f203525206f662066756e64730000000000000000000000000000000000000000606482015290519081900360840190fd5b6000868152600860205260409020600301546112d890868686866124dc565b15156112e357600080fd5b600086815260086020526040902060040180546002919060ff191660018302179055506009546040805160ff8088168252851660208201528151600160a060020a03808816948b949116927fb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611929081900390910190a450600195945050505050565b6000808080808080600160f860020a031960f860020a89831a021615156113d6576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040812054901a60f860020a02600160f860020a031916151561144d576040805160e560020a62461bcd02815260206004820152600e60248201527f4a6f62206d757374206578697374000000000000000000000000000000000000604482015290519081900360640190fd5b60008881526008602052604090206003015461146890611d93565b959e949d50929b5090995097509550909350915050565b600080836040518082805190602001908083835b602083106114b25780518252601f199092019160209182019101611493565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b6020831061150e5780518252601f1990920191602091820191016114ef565b51815160209384036101000a600019018019909216911617905292019485525060405193849003019092205460ff16925050505b92915050565b604080516c01000000000000000000000000308102602080840191909152600160a060020a03861690910260348301527f656d657267656e63795472616e73666572000000000000000000000000000000604883015282516039818403018152605990920192839052815160009384938493909282918401908083835b602083106115e45780518252601f1990920191602091820191016115c5565b5181516020939093036101000a6000190180199091169216919091179052604080519190930181900381206007547f4fa6caf600000000000000000000000000000000000000000000000000000000835260048301829052602483018b90528451919750600160a060020a03169550634fa6caf69450604480830194935090918290030181600087803b15801561167a57600080fd5b505af115801561168e573d6000803e3d6000fd5b505050506040513d60408110156116a457600080fd5b50805160209091015190969095509350505050565b60408051808201909152600581527f61646d696e000000000000000000000000000000000000000000000000000000602082015281565b604080516c01000000000000000000000000308102602080840191909152600160a060020a03851690910260348301527f656d657267656e63795472616e736665720000000000000000000000000000006048830152825160398184030181526059909201928390528151600093849392909182918401908083835b6020831061178b5780518252601f19909201916020918201910161176c565b51815160209384036101000a6000190180199092169116179052604080519290940182900382206007547f46aaf139000000000000000000000000000000000000000000000000000000008452600484018290529451909750600160a060020a0390941695506346aaf139945060248083019491935090918290030181600087803b15801561181957600080fd5b505af115801561182d573d6000803e3d6000fd5b505050506040513d602081101561184357600080fd5b505160ff1691505b50919050565b6000600160f860020a031960f860020a86831a0216151561187157600080fd5b600085815260086020526040812054901a60f860020a02600160f860020a0319161561189c57600080fd5b6000858152600860205260409020858155600181018054600160a060020a0387811673ffffffffffffffffffffffffffffffffffffffff19928316179092556002830180549287169290911691909117905560048101805460ff1916905560050182905561190b848484612c3c565b600086815260086020908152604091829020600301929092556009548151600160a060020a0388811682529381018690528251848816948a949316927f06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e928290030190a4506001949350505050565b6000808080808080600160f860020a031960f860020a89831a021615156119eb576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040812054901a60f860020a02600160f860020a0319161515611a62576040805160e560020a62461bcd02815260206004820152600e60248201527f4a6f62206d757374206578697374000000000000000000000000000000000000604482015290519081900360640190fd5b60008881526008602052604090206003015461146890610c46565b6040805190810160405280600781526020017f43616e576f726b000000000000000000000000000000000000000000000000008152506040805190810160405280600581526020017f302e312e32000000000000000000000000000000000000000000000000000000815250611af3828261147f565b15611afd57600080fd5b600160a060020a03861615801590611b1d5750600160a060020a03851615155b8015611b315750600160a060020a03841615155b1515611b87576040805160e560020a62461bcd02815260206004820152601760248201527f416464726573736573206d7573742062652076616c6964000000000000000000604482015290519081900360640190fd5b611b9386868686613001565b600a805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0388161790556040805181815283519181019190915282517fdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea39184918491908190602080830191606084019187019080838360005b83811015611c22578181015183820152602001611c0a565b50505050905090810190601f168015611c4f5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b83811015611c82578181015183820152602001611c6a565b50505050905090810190601f168015611caf5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a160016000836040518082805190602001908083835b60208310611cf25780518252601f199092019160209182019101611cd3565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b60208310611d4e5780518252601f199092019160209182019101611d2f565b51815160209384036101000a60001901801990921691161790529201948552506040519384900301909220805460ff1916931515939093179092555050505050505050565b60008060008060008060008088118015611dbc5750600088815260066020819052604082200154115b1515611e12576040805160e560020a62461bcd02815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b5050506000948552505060066020525050604090206003810154600482015460088301546009840154600a850154600b860154600c90960154949693959294919390929190565b60008060008381526006602052604090206005015460ff166002811115611e7c57fe5b14611ed1576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b600082815260066020526040902060020154600160a060020a03163314611f67576040805160e560020a62461bcd028152602060048201526024808201527f5472616e73616374696f6e206d7573742062652073656e742062792070726f7660448201527f6964657200000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b611f7082613182565b600083815260066020908152604080832060088101859055600b810185905560058101805460ff1916600217905543600782015560018054910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b158015611ffb57600080fd5b505af115801561200f573d6000803e3d6000fd5b505050506040513d602081101561202557600080fd5b5051151561207d576040805160e560020a62461bcd02815260206004820152601b60248201527f436c69656e74206d7573742072656365697665207061796d656e740000000000604482015290519081900360640190fd5b6003546040518391600160a060020a0316907f42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd672690600090a3506001919050565b6005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600080808060008581526006602052604090206005015460ff16600281111561211157fe5b14612166576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b600084815260066020526040902060010154600160a060020a031633146121fd576040805160e560020a62461bcd02815260206004820152602660248201527f5472616e73616374696f6e206d7573742062652073656e74206279207468652060448201527f636c69656e740000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600084815260066020526040902060058101805460ff191660011790554360079091015561222a84613182565b600085815260066020526040902060080181905560045461226491606491612258919063ffffffff6132f716565b9063ffffffff61332016565b9150600082111561235f576000848152600660209081526040808320600901859055600154600354825160e060020a63a9059cbb028152600160a060020a03918216600482015260248101889052925191169363a9059cbb93604480850194919392918390030190829087803b1580156122dd57600080fd5b505af11580156122f1573d6000803e3d6000fd5b505050506040513d602081101561230757600080fd5b5051151561235f576040805160e560020a62461bcd02815260206004820152601960248201527f44617070206d7573742072656365697665207061796d656e7400000000000000604482015290519081900360640190fd5b600084815260066020526040902060080154612381908363ffffffff61333516565b6000858152600660209081526040808320600a8101859055600154600290910154825160e060020a63a9059cbb028152600160a060020a039182166004820152602481018790529251959650169363a9059cbb93604480840194938390030190829087803b1580156123f257600080fd5b505af1158015612406573d6000803e3d6000fd5b505050506040513d602081101561241c57600080fd5b5051151561249a576040805160e560020a62461bcd02815260206004820152602660248201527f457363726f77206d75737420686f6c6420656e6f7567682043414e20666f722060448201527f7061796f75740000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6003546040518591600160a060020a0316907f4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a90600090a35060019392505050565b600080808060008981526006602052604090206005015460ff16600281111561250157fe5b14612556576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b60008760ff161015801561256e575060008660ff1610155b801561257e575060008460ff1610155b801561258e575060648760ff1611155b801561259e575060648660ff1611155b80156125ae575060648460ff1611155b151561262a576040805160e560020a62461bcd02815260206004820152603660248201527f5061796d656e747320746f20636c69656e742c2070726f766964657220616e6460448201527f2061726269746572206d75737420626520677465203000000000000000000000606482015290519081900360840190fd5b606460ff888801860116146126af576040805160e560020a62461bcd02815260206004820152602360248201527f546f74616c207061796f7574206d75737420657175616c20313030207065726360448201527f656e740000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600088815260066020526040902060058101805460ff19166002179055436007909101556126dc88613182565b600089815260066020526040902060080181905560045461270a91606491612258919063ffffffff6132f716565b91506000821115612805576000888152600660209081526040808320600901859055600154600354825160e060020a63a9059cbb028152600160a060020a03918216600482015260248101889052925191169363a9059cbb93604480850194919392918390030190829087803b15801561278357600080fd5b505af1158015612797573d6000803e3d6000fd5b505050506040513d60208110156127ad57600080fd5b50511515612805576040805160e560020a62461bcd02815260206004820152601960248201527f44617070206d7573742072656365697665207061796d656e7400000000000000604482015290519081900360640190fd5b600088815260066020526040902060080154612827908363ffffffff61333516565b905060008460ff16111561299857600160a060020a0385161515612895576040805160e560020a62461bcd02815260206004820152601d60248201527f417262697465722061646472657373206d7573742062652076616c6964000000604482015290519081900360640190fd5b6128ad60646122588360ff881663ffffffff6132f716565b6000898152600660209081526040808320600c01849055600154815160e060020a63a9059cbb028152600160a060020a038b811660048301526024820196909652915194169363a9059cbb93604480840194938390030190829087803b15801561291657600080fd5b505af115801561292a573d6000803e3d6000fd5b505050506040513d602081101561294057600080fd5b50511515612998576040805160e560020a62461bcd02815260206004820152601c60248201527f41726269746572206d7573742072656365697665207061796d656e7400000000604482015290519081900360640190fd5b60008660ff161115612aaf576129bc60646122588360ff8a1663ffffffff6132f716565b6000898152600660209081526040808320600a8101859055600154600290910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b158015612a2d57600080fd5b505af1158015612a41573d6000803e3d6000fd5b505050506040513d6020811015612a5757600080fd5b50511515612aaf576040805160e560020a62461bcd02815260206004820152601d60248201527f50726f7669646572206d7573742072656365697665207061796d656e74000000604482015290519081900360640190fd5b60008760ff161115612bc457612ad360646122588360ff8b1663ffffffff6132f716565b6000898152600660209081526040808320600b810185905560018054910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b158015612b4257600080fd5b505af1158015612b56573d6000803e3d6000fd5b505050506040513d6020811015612b6c57600080fd5b50511515612bc4576040805160e560020a62461bcd02815260206004820152601b60248201527f436c69656e74206d7573742072656365697665207061796d656e740000000000604482015290519081900360640190fd5b600354600089815260066020908152604091829020600a810154600c909101548351918252918101919091528151600160a060020a03808a16948d949116927f23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b929081900390910190a4506001979650505050505050565b6000808080600160a060020a03871615801590612c615750600160a060020a03861615155b8015612c6d5750600085115b1515612ce9576040805160e560020a62461bcd02815260206004820152602e60248201527f4d75737420626520612076616c69642061646472657373657320616e64206e6f60448201527f6e207a65726f20616d6f756e7473000000000000000000000000000000000000606482015290519081900360840190fd5b600154604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a038a8116600483015230602483015260448201899052915191909216916323b872dd9160648083019260209291908290030181600087803b158015612d5e57600080fd5b505af1158015612d72573d6000803e3d6000fd5b505050506040513d6020811015612d8857600080fd5b50511515612e06576040805160e560020a62461bcd02815260206004820152603a60248201527f436c69656e74206d757374206861766520617574686f7269736174696f6e206160448201527f6e642062616c616e636520746f207472616e736665722043414e000000000000606482015290519081900360840190fd5b600554604080517f9fd650ce000000000000000000000000000000000000000000000000000000008152600481018890529051600160a060020a0390921691639fd650ce916024808201926020929091908290030181600087803b158015612e6d57600080fd5b505af1158015612e81573d6000803e3d6000fd5b505050506040513d6020811015612e9757600080fd5b5051925060008311612f18576040805160e560020a62461bcd028152602060048201526024808201527f4a6f622076616c7565206d7573742062652067726561746572207468616e203060448201527f2055534400000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b505060028054600190810180835560008181526006602081815260408084208581559586018054600160a060020a038e811673ffffffffffffffffffffffffffffffffffffffff19928316811790935598880180548e8b1692168217905560038089018d9055600489018b9055439589019590955560058801805460ff1916905560088801869055600a8801869055600b8801869055600c880195909555925481518b8152928301899052815195979495939416927f2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb9281900390910190a45095945050505050565b6040805190810160405280600a81526020017f43616e576f726b4a6f62000000000000000000000000000000000000000000008152506040805190810160405280600581526020017f302e312e33000000000000000000000000000000000000000000000000000000815250613077828261147f565b1561308157600080fd5b600160a060020a038616158015906130a15750600160a060020a03851615155b80156130b55750600160a060020a03841615155b80156130c95750600160a060020a03831615155b15156130d457600080fd5b6130df868585613347565b60078054600160a060020a0380881673ffffffffffffffffffffffffffffffffffffffff199283161790925560098054928716929091169190911790556040805181815283519181019190915282517fdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea391849184919081906020808301916060840191870190808383600083811015611c22578181015183820152602001611c0a565b600554600082815260066020908152604080832060049081015482517fc8a1d96e00000000000000000000000000000000000000000000000000000000815291820152905192938493600160a060020a039091169263c8a1d96e926024808201939182900301818787803b1580156131f957600080fd5b505af115801561320d573d6000803e3d6000fd5b505050506040513d602081101561322357600080fd5b50519050600081116132a4576040805160e560020a62461bcd028152602060048201526024808201527f4f7261636c65206d7573742072657475726e2061206e6f6e207a65726f20706160448201527f796f757400000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6000838152600660205260409020600301546132c790600263ffffffff6132f716565b8110611542576000838152600660205260409020600301546132f090600263ffffffff6132f716565b915061184b565b600082151561330857506000611542565b5081810281838281151561331857fe5b041461154257fe5b6000818381151561332d57fe5b049392505050565b60008282111561334157fe5b50900390565b6040805190810160405280600681526020017f457363726f7700000000000000000000000000000000000000000000000000008152506040805190810160405280600581526020017f302e312e330000000000000000000000000000000000000000000000000000008152506133bd828261147f565b156133c757600080fd5b600160a060020a038516158015906133e75750600160a060020a03841615155b80156133fb5750600160a060020a03831615155b1515613451576040805160e560020a62461bcd02815260206004820152601760248201527f4d7573742062652076616c696420616464726573736573000000000000000000604482015290519081900360640190fd5b60018054600160a060020a0380881673ffffffffffffffffffffffffffffffffffffffff19928316811784556003805489841690851681179091556005805493891693909416831790935560049390935560408051918252519192917f92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff09181900360200190a37fdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea38282604051808060200180602001838103835285818151815260200191508051906020019080838360005b8381101561353b578181015183820152602001613523565b50505050905090810190601f1680156135685780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561359b578181015183820152602001613583565b50505050905090810190601f1680156135c85780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a160016000836040518082805190602001908083835b6020831061360b5780518252601f1990920191602091820191016135ec565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b602083106136675780518252601f199092019160209182019101613648565b51815160209384036101000a60001901801990921691161790529201948552506040519384900301909220805460ff191693151593909317909255505050505050505600a165627a7a72305820c1e2c903331c8515ac2fa22955c371e8086a91eb20e021413d4f2789e272b1950029`

// DeployCanWork deploys a new Ethereum contract, binding an instance of CanWork to it.
func DeployCanWork(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CanWork, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CanWorkBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CanWork{CanWorkCaller: CanWorkCaller{contract: contract}, CanWorkTransactor: CanWorkTransactor{contract: contract}, CanWorkFilterer: CanWorkFilterer{contract: contract}}, nil
}

// CanWork is an auto generated Go binding around an Ethereum contract.
type CanWork struct {
	CanWorkCaller     // Read-only binding to the contract
	CanWorkTransactor // Write-only binding to the contract
	CanWorkFilterer   // Log filterer for contract events
}

// CanWorkCaller is an auto generated read-only Go binding around an Ethereum contract.
type CanWorkCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CanWorkTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CanWorkFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CanWorkSession struct {
	Contract     *CanWork          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CanWorkCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CanWorkCallerSession struct {
	Contract *CanWorkCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// CanWorkTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CanWorkTransactorSession struct {
	Contract     *CanWorkTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// CanWorkRaw is an auto generated low-level Go binding around an Ethereum contract.
type CanWorkRaw struct {
	Contract *CanWork // Generic contract binding to access the raw methods on
}

// CanWorkCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CanWorkCallerRaw struct {
	Contract *CanWorkCaller // Generic read-only contract binding to access the raw methods on
}

// CanWorkTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CanWorkTransactorRaw struct {
	Contract *CanWorkTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCanWork creates a new instance of CanWork, bound to a specific deployed contract.
func NewCanWork(address common.Address, backend bind.ContractBackend) (*CanWork, error) {
	contract, err := bindCanWork(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CanWork{CanWorkCaller: CanWorkCaller{contract: contract}, CanWorkTransactor: CanWorkTransactor{contract: contract}, CanWorkFilterer: CanWorkFilterer{contract: contract}}, nil
}

// NewCanWorkCaller creates a new read-only instance of CanWork, bound to a specific deployed contract.
func NewCanWorkCaller(address common.Address, caller bind.ContractCaller) (*CanWorkCaller, error) {
	contract, err := bindCanWork(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkCaller{contract: contract}, nil
}

// NewCanWorkTransactor creates a new write-only instance of CanWork, bound to a specific deployed contract.
func NewCanWorkTransactor(address common.Address, transactor bind.ContractTransactor) (*CanWorkTransactor, error) {
	contract, err := bindCanWork(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkTransactor{contract: contract}, nil
}

// NewCanWorkFilterer creates a new log filterer instance of CanWork, bound to a specific deployed contract.
func NewCanWorkFilterer(address common.Address, filterer bind.ContractFilterer) (*CanWorkFilterer, error) {
	contract, err := bindCanWork(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CanWorkFilterer{contract: contract}, nil
}

// bindCanWork binds a generic wrapper to an already deployed contract.
func bindCanWork(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWork *CanWorkRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWork.Contract.CanWorkCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWork *CanWorkRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWork.Contract.CanWorkTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWork *CanWorkRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWork.Contract.CanWorkTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWork *CanWorkCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWork.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWork *CanWorkTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWork.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWork *CanWorkTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWork.Contract.contract.Transact(opts, method, params...)
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWork *CanWorkCaller) ROLEADMIN(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CanWork.contract.Call(opts, out, "ROLE_ADMIN")
	return *ret0, err
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWork *CanWorkSession) ROLEADMIN() (string, error) {
	return _CanWork.Contract.ROLEADMIN(&_CanWork.CallOpts)
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWork *CanWorkCallerSession) ROLEADMIN() (string, error) {
	return _CanWork.Contract.ROLEADMIN(&_CanWork.CallOpts)
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWork *CanWorkCaller) ROLEOWNER(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CanWork.contract.Call(opts, out, "ROLE_OWNER")
	return *ret0, err
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWork *CanWorkSession) ROLEOWNER() (string, error) {
	return _CanWork.Contract.ROLEOWNER(&_CanWork.CallOpts)
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWork *CanWorkCallerSession) ROLEOWNER() (string, error) {
	return _CanWork.Contract.ROLEOWNER(&_CanWork.CallOpts)
}

// GetEmergencyTransferSigner is a free data retrieval call binding the contract method 0xd047a0d0.
//
// Solidity: function getEmergencyTransferSigner(_toAddress address, index uint256) constant returns(address, bool)
func (_CanWork *CanWorkCaller) GetEmergencyTransferSigner(opts *bind.CallOpts, _toAddress common.Address, index *big.Int) (common.Address, bool, error) {
	var (
		ret0 = new(common.Address)
		ret1 = new(bool)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CanWork.contract.Call(opts, out, "getEmergencyTransferSigner", _toAddress, index)
	return *ret0, *ret1, err
}

// GetEmergencyTransferSigner is a free data retrieval call binding the contract method 0xd047a0d0.
//
// Solidity: function getEmergencyTransferSigner(_toAddress address, index uint256) constant returns(address, bool)
func (_CanWork *CanWorkSession) GetEmergencyTransferSigner(_toAddress common.Address, index *big.Int) (common.Address, bool, error) {
	return _CanWork.Contract.GetEmergencyTransferSigner(&_CanWork.CallOpts, _toAddress, index)
}

// GetEmergencyTransferSigner is a free data retrieval call binding the contract method 0xd047a0d0.
//
// Solidity: function getEmergencyTransferSigner(_toAddress address, index uint256) constant returns(address, bool)
func (_CanWork *CanWorkCallerSession) GetEmergencyTransferSigner(_toAddress common.Address, index *big.Int) (common.Address, bool, error) {
	return _CanWork.Contract.GetEmergencyTransferSigner(&_CanWork.CallOpts, _toAddress, index)
}

// GetEmergencyTransferSignersCount is a free data retrieval call binding the contract method 0xdea90acf.
//
// Solidity: function getEmergencyTransferSignersCount(_toAddress address) constant returns(uint256)
func (_CanWork *CanWorkCaller) GetEmergencyTransferSignersCount(opts *bind.CallOpts, _toAddress common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CanWork.contract.Call(opts, out, "getEmergencyTransferSignersCount", _toAddress)
	return *ret0, err
}

// GetEmergencyTransferSignersCount is a free data retrieval call binding the contract method 0xdea90acf.
//
// Solidity: function getEmergencyTransferSignersCount(_toAddress address) constant returns(uint256)
func (_CanWork *CanWorkSession) GetEmergencyTransferSignersCount(_toAddress common.Address) (*big.Int, error) {
	return _CanWork.Contract.GetEmergencyTransferSignersCount(&_CanWork.CallOpts, _toAddress)
}

// GetEmergencyTransferSignersCount is a free data retrieval call binding the contract method 0xdea90acf.
//
// Solidity: function getEmergencyTransferSignersCount(_toAddress address) constant returns(uint256)
func (_CanWork *CanWorkCallerSession) GetEmergencyTransferSignersCount(_toAddress common.Address) (*big.Int, error) {
	return _CanWork.Contract.GetEmergencyTransferSignersCount(&_CanWork.CallOpts, _toAddress)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkCaller) GetEscrow(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	ret := new(struct {
		Client        common.Address
		Provider      common.Address
		Amount        *big.Int
		TotalValueDai *big.Int
		Status        uint8
		CreatedAt     *big.Int
		ClosedAt      *big.Int
	})
	out := ret
	err := _CanWork.contract.Call(opts, out, "getEscrow", _escrowId)
	return *ret, err
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _CanWork.Contract.GetEscrow(&_CanWork.CallOpts, _escrowId)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkCallerSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _CanWork.Contract.GetEscrow(&_CanWork.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkCaller) GetEscrowPayments(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	ret := new(struct {
		Amount               *big.Int
		TotalValueDai        *big.Int
		PayoutAmount         *big.Int
		PaidToDappAmount     *big.Int
		PaidToProviderAmount *big.Int
		PaidToClientAmount   *big.Int
		PaidToArbiterAmount  *big.Int
	})
	out := ret
	err := _CanWork.contract.Call(opts, out, "getEscrowPayments", _escrowId)
	return *ret, err
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWork.Contract.GetEscrowPayments(&_CanWork.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkCallerSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWork.Contract.GetEscrowPayments(&_CanWork.CallOpts, _escrowId)
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkCaller) GetJob(opts *bind.CallOpts, _jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	ret := new(struct {
		Client     common.Address
		Provider   common.Address
		Amount     *big.Int
		ValueInDai *big.Int
		Status     uint8
		CreatedAt  *big.Int
		ClosedAt   *big.Int
	})
	out := ret
	err := _CanWork.contract.Call(opts, out, "getJob", _jobId)
	return *ret, err
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkSession) GetJob(_jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	return _CanWork.Contract.GetJob(&_CanWork.CallOpts, _jobId)
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWork *CanWorkCallerSession) GetJob(_jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	return _CanWork.Contract.GetJob(&_CanWork.CallOpts, _jobId)
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkCaller) GetJobPayments(opts *bind.CallOpts, _jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	ret := new(struct {
		Amount               *big.Int
		ValueInDai           *big.Int
		PayoutAmount         *big.Int
		PaidToDappAmount     *big.Int
		PaidToProviderAmount *big.Int
		PaidToClientAmount   *big.Int
		PaidToArbiterAmount  *big.Int
	})
	out := ret
	err := _CanWork.contract.Call(opts, out, "getJobPayments", _jobId)
	return *ret, err
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkSession) GetJobPayments(_jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWork.Contract.GetJobPayments(&_CanWork.CallOpts, _jobId)
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWork *CanWorkCallerSession) GetJobPayments(_jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWork.Contract.GetJobPayments(&_CanWork.CallOpts, _jobId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWork *CanWorkCaller) IsMigrated(opts *bind.CallOpts, contractName string, migrationId string) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CanWork.contract.Call(opts, out, "isMigrated", contractName, migrationId)
	return *ret0, err
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWork *CanWorkSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _CanWork.Contract.IsMigrated(&_CanWork.CallOpts, contractName, migrationId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWork *CanWorkCallerSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _CanWork.Contract.IsMigrated(&_CanWork.CallOpts, contractName, migrationId)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWork *CanWorkCaller) PriceOracle(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CanWork.contract.Call(opts, out, "priceOracle")
	return *ret0, err
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWork *CanWorkSession) PriceOracle() (common.Address, error) {
	return _CanWork.Contract.PriceOracle(&_CanWork.CallOpts)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWork *CanWorkCallerSession) PriceOracle() (common.Address, error) {
	return _CanWork.Contract.PriceOracle(&_CanWork.CallOpts)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWork *CanWorkTransactor) CancelJobByAdmin(opts *bind.TransactOpts, _jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "cancelJobByAdmin", _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWork *CanWorkSession) CancelJobByAdmin(_jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWork.Contract.CancelJobByAdmin(&_CanWork.TransactOpts, _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWork *CanWorkTransactorSession) CancelJobByAdmin(_jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWork.Contract.CancelJobByAdmin(&_CanWork.TransactOpts, _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkTransactor) CancelJobByProvider(opts *bind.TransactOpts, _jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "cancelJobByProvider", _jobId)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkSession) CancelJobByProvider(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.Contract.CancelJobByProvider(&_CanWork.TransactOpts, _jobId)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkTransactorSession) CancelJobByProvider(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.Contract.CancelJobByProvider(&_CanWork.TransactOpts, _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkTransactor) CompleteJob(opts *bind.TransactOpts, _jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "completeJob", _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkSession) CompleteJob(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.Contract.CompleteJob(&_CanWork.TransactOpts, _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWork *CanWorkTransactorSession) CompleteJob(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWork.Contract.CompleteJob(&_CanWork.TransactOpts, _jobId)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWork *CanWorkTransactor) CreateJob(opts *bind.TransactOpts, _jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "createJob", _jobId, _client, _provider, _totalCosts)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWork *CanWorkSession) CreateJob(_jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWork.Contract.CreateJob(&_CanWork.TransactOpts, _jobId, _client, _provider, _totalCosts)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWork *CanWorkTransactorSession) CreateJob(_jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWork.Contract.CreateJob(&_CanWork.TransactOpts, _jobId, _client, _provider, _totalCosts)
}

// EmergencyTransfer is a paid mutator transaction binding the contract method 0x0e501834.
//
// Solidity: function emergencyTransfer(toAddress address) returns(bool)
func (_CanWork *CanWorkTransactor) EmergencyTransfer(opts *bind.TransactOpts, toAddress common.Address) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "emergencyTransfer", toAddress)
}

// EmergencyTransfer is a paid mutator transaction binding the contract method 0x0e501834.
//
// Solidity: function emergencyTransfer(toAddress address) returns(bool)
func (_CanWork *CanWorkSession) EmergencyTransfer(toAddress common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.EmergencyTransfer(&_CanWork.TransactOpts, toAddress)
}

// EmergencyTransfer is a paid mutator transaction binding the contract method 0x0e501834.
//
// Solidity: function emergencyTransfer(toAddress address) returns(bool)
func (_CanWork *CanWorkTransactorSession) EmergencyTransfer(toAddress common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.EmergencyTransfer(&_CanWork.TransactOpts, toAddress)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWork *CanWorkTransactor) Initialize(opts *bind.TransactOpts, _token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "initialize", _token, _canworkAdmin, _dApp, _priceOracle)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWork *CanWorkSession) Initialize(_token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.Initialize(&_CanWork.TransactOpts, _token, _canworkAdmin, _dApp, _priceOracle)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWork *CanWorkTransactorSession) Initialize(_token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.Initialize(&_CanWork.TransactOpts, _token, _canworkAdmin, _dApp, _priceOracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWork *CanWorkTransactor) UpdatePriceOracleAddress(opts *bind.TransactOpts, _oracle common.Address) (*types.Transaction, error) {
	return _CanWork.contract.Transact(opts, "updatePriceOracleAddress", _oracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWork *CanWorkSession) UpdatePriceOracleAddress(_oracle common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.UpdatePriceOracleAddress(&_CanWork.TransactOpts, _oracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWork *CanWorkTransactorSession) UpdatePriceOracleAddress(_oracle common.Address) (*types.Transaction, error) {
	return _CanWork.Contract.UpdatePriceOracleAddress(&_CanWork.TransactOpts, _oracle)
}

// CanWorkMigratedIterator is returned from FilterMigrated and is used to iterate over the raw logs and unpacked data for Migrated events raised by the CanWork contract.
type CanWorkMigratedIterator struct {
	Event *CanWorkMigrated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkMigratedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkMigrated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkMigrated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkMigratedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkMigratedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkMigrated represents a Migrated event raised by the CanWork contract.
type CanWorkMigrated struct {
	ContractName string
	MigrationId  string
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterMigrated is a free log retrieval operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_CanWork *CanWorkFilterer) FilterMigrated(opts *bind.FilterOpts) (*CanWorkMigratedIterator, error) {

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return &CanWorkMigratedIterator{contract: _CanWork.contract, event: "Migrated", logs: logs, sub: sub}, nil
}

// WatchMigrated is a free log subscription operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_CanWork *CanWorkFilterer) WatchMigrated(opts *bind.WatchOpts, sink chan<- *CanWorkMigrated) (event.Subscription, error) {

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkMigrated)
				if err := _CanWork.contract.UnpackLog(event, "Migrated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCancelEscrowIterator is returned from FilterOnCancelEscrow and is used to iterate over the raw logs and unpacked data for OnCancelEscrow events raised by the CanWork contract.
type CanWorkOnCancelEscrowIterator struct {
	Event *CanWorkOnCancelEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCancelEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCancelEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCancelEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCancelEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCancelEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCancelEscrow represents a OnCancelEscrow event raised by the CanWork contract.
type CanWorkOnCancelEscrow struct {
	Dapp                common.Address
	EscrowId            *big.Int
	PayToProviderAmount *big.Int
	Arbiter             common.Address
	PayToArbiterAmount  *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrow is a free log retrieval operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_CanWork *CanWorkFilterer) FilterOnCancelEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (*CanWorkOnCancelEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCancelEscrowIterator{contract: _CanWork.contract, event: "OnCancelEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrow is a free log subscription operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_CanWork *CanWorkFilterer) WatchOnCancelEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkOnCancelEscrow, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCancelEscrow)
				if err := _CanWork.contract.UnpackLog(event, "OnCancelEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCancelEscrowByProviderIterator is returned from FilterOnCancelEscrowByProvider and is used to iterate over the raw logs and unpacked data for OnCancelEscrowByProvider events raised by the CanWork contract.
type CanWorkOnCancelEscrowByProviderIterator struct {
	Event *CanWorkOnCancelEscrowByProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCancelEscrowByProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCancelEscrowByProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCancelEscrowByProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCancelEscrowByProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCancelEscrowByProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCancelEscrowByProvider represents a OnCancelEscrowByProvider event raised by the CanWork contract.
type CanWorkOnCancelEscrowByProvider struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrowByProvider is a free log retrieval operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_CanWork *CanWorkFilterer) FilterOnCancelEscrowByProvider(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*CanWorkOnCancelEscrowByProviderIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCancelEscrowByProviderIterator{contract: _CanWork.contract, event: "OnCancelEscrowByProvider", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrowByProvider is a free log subscription operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_CanWork *CanWorkFilterer) WatchOnCancelEscrowByProvider(opts *bind.WatchOpts, sink chan<- *CanWorkOnCancelEscrowByProvider, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCancelEscrowByProvider)
				if err := _CanWork.contract.UnpackLog(event, "OnCancelEscrowByProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCancelJobByAdminIterator is returned from FilterOnCancelJobByAdmin and is used to iterate over the raw logs and unpacked data for OnCancelJobByAdmin events raised by the CanWork contract.
type CanWorkOnCancelJobByAdminIterator struct {
	Event *CanWorkOnCancelJobByAdmin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCancelJobByAdminIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCancelJobByAdmin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCancelJobByAdmin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCancelJobByAdminIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCancelJobByAdminIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCancelJobByAdmin represents a OnCancelJobByAdmin event raised by the CanWork contract.
type CanWorkOnCancelJobByAdmin struct {
	Dapp                    common.Address
	JobId                   [32]byte
	PayToProviderPercentage uint8
	Arbiter                 common.Address
	PayToArbiterPercentage  uint8
	Raw                     types.Log // Blockchain specific contextual infos
}

// FilterOnCancelJobByAdmin is a free log retrieval operation binding the contract event 0xb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611.
//
// Solidity: e OnCancelJobByAdmin(dapp indexed address, jobId indexed bytes32, payToProviderPercentage uint8, arbiter indexed address, payToArbiterPercentage uint8)
func (_CanWork *CanWorkFilterer) FilterOnCancelJobByAdmin(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte, arbiter []common.Address) (*CanWorkOnCancelJobByAdminIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCancelJobByAdmin", dappRule, jobIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCancelJobByAdminIterator{contract: _CanWork.contract, event: "OnCancelJobByAdmin", logs: logs, sub: sub}, nil
}

// WatchOnCancelJobByAdmin is a free log subscription operation binding the contract event 0xb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611.
//
// Solidity: e OnCancelJobByAdmin(dapp indexed address, jobId indexed bytes32, payToProviderPercentage uint8, arbiter indexed address, payToArbiterPercentage uint8)
func (_CanWork *CanWorkFilterer) WatchOnCancelJobByAdmin(opts *bind.WatchOpts, sink chan<- *CanWorkOnCancelJobByAdmin, dapp []common.Address, jobId [][32]byte, arbiter []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCancelJobByAdmin", dappRule, jobIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCancelJobByAdmin)
				if err := _CanWork.contract.UnpackLog(event, "OnCancelJobByAdmin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCancelJobByProviderIterator is returned from FilterOnCancelJobByProvider and is used to iterate over the raw logs and unpacked data for OnCancelJobByProvider events raised by the CanWork contract.
type CanWorkOnCancelJobByProviderIterator struct {
	Event *CanWorkOnCancelJobByProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCancelJobByProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCancelJobByProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCancelJobByProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCancelJobByProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCancelJobByProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCancelJobByProvider represents a OnCancelJobByProvider event raised by the CanWork contract.
type CanWorkOnCancelJobByProvider struct {
	Dapp  common.Address
	JobId [32]byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterOnCancelJobByProvider is a free log retrieval operation binding the contract event 0x9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c426.
//
// Solidity: e OnCancelJobByProvider(dapp indexed address, jobId indexed bytes32)
func (_CanWork *CanWorkFilterer) FilterOnCancelJobByProvider(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte) (*CanWorkOnCancelJobByProviderIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCancelJobByProvider", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCancelJobByProviderIterator{contract: _CanWork.contract, event: "OnCancelJobByProvider", logs: logs, sub: sub}, nil
}

// WatchOnCancelJobByProvider is a free log subscription operation binding the contract event 0x9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c426.
//
// Solidity: e OnCancelJobByProvider(dapp indexed address, jobId indexed bytes32)
func (_CanWork *CanWorkFilterer) WatchOnCancelJobByProvider(opts *bind.WatchOpts, sink chan<- *CanWorkOnCancelJobByProvider, dapp []common.Address, jobId [][32]byte) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCancelJobByProvider", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCancelJobByProvider)
				if err := _CanWork.contract.UnpackLog(event, "OnCancelJobByProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCompleteEscrowIterator is returned from FilterOnCompleteEscrow and is used to iterate over the raw logs and unpacked data for OnCompleteEscrow events raised by the CanWork contract.
type CanWorkOnCompleteEscrowIterator struct {
	Event *CanWorkOnCompleteEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCompleteEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCompleteEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCompleteEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCompleteEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCompleteEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCompleteEscrow represents a OnCompleteEscrow event raised by the CanWork contract.
type CanWorkOnCompleteEscrow struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCompleteEscrow is a free log retrieval operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_CanWork *CanWorkFilterer) FilterOnCompleteEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*CanWorkOnCompleteEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCompleteEscrowIterator{contract: _CanWork.contract, event: "OnCompleteEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCompleteEscrow is a free log subscription operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_CanWork *CanWorkFilterer) WatchOnCompleteEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkOnCompleteEscrow, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCompleteEscrow)
				if err := _CanWork.contract.UnpackLog(event, "OnCompleteEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCompleteJobIterator is returned from FilterOnCompleteJob and is used to iterate over the raw logs and unpacked data for OnCompleteJob events raised by the CanWork contract.
type CanWorkOnCompleteJobIterator struct {
	Event *CanWorkOnCompleteJob // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCompleteJobIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCompleteJob)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCompleteJob)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCompleteJobIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCompleteJobIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCompleteJob represents a OnCompleteJob event raised by the CanWork contract.
type CanWorkOnCompleteJob struct {
	Dapp  common.Address
	JobId [32]byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterOnCompleteJob is a free log retrieval operation binding the contract event 0x5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a.
//
// Solidity: e OnCompleteJob(dapp indexed address, jobId indexed bytes32)
func (_CanWork *CanWorkFilterer) FilterOnCompleteJob(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte) (*CanWorkOnCompleteJobIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCompleteJob", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCompleteJobIterator{contract: _CanWork.contract, event: "OnCompleteJob", logs: logs, sub: sub}, nil
}

// WatchOnCompleteJob is a free log subscription operation binding the contract event 0x5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a.
//
// Solidity: e OnCompleteJob(dapp indexed address, jobId indexed bytes32)
func (_CanWork *CanWorkFilterer) WatchOnCompleteJob(opts *bind.WatchOpts, sink chan<- *CanWorkOnCompleteJob, dapp []common.Address, jobId [][32]byte) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCompleteJob", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCompleteJob)
				if err := _CanWork.contract.UnpackLog(event, "OnCompleteJob", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCreateEscrowIterator is returned from FilterOnCreateEscrow and is used to iterate over the raw logs and unpacked data for OnCreateEscrow events raised by the CanWork contract.
type CanWorkOnCreateEscrowIterator struct {
	Event *CanWorkOnCreateEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCreateEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCreateEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCreateEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCreateEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCreateEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCreateEscrow represents a OnCreateEscrow event raised by the CanWork contract.
type CanWorkOnCreateEscrow struct {
	Dapp      common.Address
	Client    common.Address
	Provider  common.Address
	Amount    *big.Int
	DaiAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterOnCreateEscrow is a free log retrieval operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_CanWork *CanWorkFilterer) FilterOnCreateEscrow(opts *bind.FilterOpts, dapp []common.Address, client []common.Address, provider []common.Address) (*CanWorkOnCreateEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCreateEscrowIterator{contract: _CanWork.contract, event: "OnCreateEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCreateEscrow is a free log subscription operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_CanWork *CanWorkFilterer) WatchOnCreateEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkOnCreateEscrow, dapp []common.Address, client []common.Address, provider []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCreateEscrow)
				if err := _CanWork.contract.UnpackLog(event, "OnCreateEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnCreateJobIterator is returned from FilterOnCreateJob and is used to iterate over the raw logs and unpacked data for OnCreateJob events raised by the CanWork contract.
type CanWorkOnCreateJobIterator struct {
	Event *CanWorkOnCreateJob // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnCreateJobIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnCreateJob)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnCreateJob)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnCreateJobIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnCreateJobIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnCreateJob represents a OnCreateJob event raised by the CanWork contract.
type CanWorkOnCreateJob struct {
	Dapp       common.Address
	JobId      [32]byte
	Client     common.Address
	Provider   common.Address
	TotalCosts *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterOnCreateJob is a free log retrieval operation binding the contract event 0x06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e.
//
// Solidity: e OnCreateJob(dapp indexed address, jobId indexed bytes32, client address, provider indexed address, totalCosts uint256)
func (_CanWork *CanWorkFilterer) FilterOnCreateJob(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte, provider []common.Address) (*CanWorkOnCreateJobIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnCreateJob", dappRule, jobIdRule, providerRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnCreateJobIterator{contract: _CanWork.contract, event: "OnCreateJob", logs: logs, sub: sub}, nil
}

// WatchOnCreateJob is a free log subscription operation binding the contract event 0x06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e.
//
// Solidity: e OnCreateJob(dapp indexed address, jobId indexed bytes32, client address, provider indexed address, totalCosts uint256)
func (_CanWork *CanWorkFilterer) WatchOnCreateJob(opts *bind.WatchOpts, sink chan<- *CanWorkOnCreateJob, dapp []common.Address, jobId [][32]byte, provider []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnCreateJob", dappRule, jobIdRule, providerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnCreateJob)
				if err := _CanWork.contract.UnpackLog(event, "OnCreateJob", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnEmeregencyTransferIterator is returned from FilterOnEmeregencyTransfer and is used to iterate over the raw logs and unpacked data for OnEmeregencyTransfer events raised by the CanWork contract.
type CanWorkOnEmeregencyTransferIterator struct {
	Event *CanWorkOnEmeregencyTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnEmeregencyTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnEmeregencyTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnEmeregencyTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnEmeregencyTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnEmeregencyTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnEmeregencyTransfer represents a OnEmeregencyTransfer event raised by the CanWork contract.
type CanWorkOnEmeregencyTransfer struct {
	ToAddress common.Address
	Balance   *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterOnEmeregencyTransfer is a free log retrieval operation binding the contract event 0xd52f490db8aced6e82c33e39d01bca1886f5e9579c9e3347e8a89d60ad39bb09.
//
// Solidity: e OnEmeregencyTransfer(toAddress indexed address, balance uint256)
func (_CanWork *CanWorkFilterer) FilterOnEmeregencyTransfer(opts *bind.FilterOpts, toAddress []common.Address) (*CanWorkOnEmeregencyTransferIterator, error) {

	var toAddressRule []interface{}
	for _, toAddressItem := range toAddress {
		toAddressRule = append(toAddressRule, toAddressItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnEmeregencyTransfer", toAddressRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnEmeregencyTransferIterator{contract: _CanWork.contract, event: "OnEmeregencyTransfer", logs: logs, sub: sub}, nil
}

// WatchOnEmeregencyTransfer is a free log subscription operation binding the contract event 0xd52f490db8aced6e82c33e39d01bca1886f5e9579c9e3347e8a89d60ad39bb09.
//
// Solidity: e OnEmeregencyTransfer(toAddress indexed address, balance uint256)
func (_CanWork *CanWorkFilterer) WatchOnEmeregencyTransfer(opts *bind.WatchOpts, sink chan<- *CanWorkOnEmeregencyTransfer, toAddress []common.Address) (event.Subscription, error) {

	var toAddressRule []interface{}
	for _, toAddressItem := range toAddress {
		toAddressRule = append(toAddressRule, toAddressItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnEmeregencyTransfer", toAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnEmeregencyTransfer)
				if err := _CanWork.contract.UnpackLog(event, "OnEmeregencyTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkOnInitializeIterator is returned from FilterOnInitialize and is used to iterate over the raw logs and unpacked data for OnInitialize events raised by the CanWork contract.
type CanWorkOnInitializeIterator struct {
	Event *CanWorkOnInitialize // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkOnInitializeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkOnInitialize)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkOnInitialize)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkOnInitializeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkOnInitializeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkOnInitialize represents a OnInitialize event raised by the CanWork contract.
type CanWorkOnInitialize struct {
	Token       common.Address
	DApp        common.Address
	PriceOracle common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterOnInitialize is a free log retrieval operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_CanWork *CanWorkFilterer) FilterOnInitialize(opts *bind.FilterOpts, token []common.Address, dApp []common.Address) (*CanWorkOnInitializeIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _CanWork.contract.FilterLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkOnInitializeIterator{contract: _CanWork.contract, event: "OnInitialize", logs: logs, sub: sub}, nil
}

// WatchOnInitialize is a free log subscription operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_CanWork *CanWorkFilterer) WatchOnInitialize(opts *bind.WatchOpts, sink chan<- *CanWorkOnInitialize, token []common.Address, dApp []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _CanWork.contract.WatchLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkOnInitialize)
				if err := _CanWork.contract.UnpackLog(event, "OnInitialize", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkAdminABI is the input ABI used to generate the binding from.
const CanWorkAdminABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"roleName\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getSignersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"resetSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"addSig\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// CanWorkAdminBin is the compiled bytecode used for deploying new contracts.
const CanWorkAdminBin = `0x`

// DeployCanWorkAdmin deploys a new Ethereum contract, binding an instance of CanWorkAdmin to it.
func DeployCanWorkAdmin(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CanWorkAdmin, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkAdminABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CanWorkAdminBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CanWorkAdmin{CanWorkAdminCaller: CanWorkAdminCaller{contract: contract}, CanWorkAdminTransactor: CanWorkAdminTransactor{contract: contract}, CanWorkAdminFilterer: CanWorkAdminFilterer{contract: contract}}, nil
}

// CanWorkAdmin is an auto generated Go binding around an Ethereum contract.
type CanWorkAdmin struct {
	CanWorkAdminCaller     // Read-only binding to the contract
	CanWorkAdminTransactor // Write-only binding to the contract
	CanWorkAdminFilterer   // Log filterer for contract events
}

// CanWorkAdminCaller is an auto generated read-only Go binding around an Ethereum contract.
type CanWorkAdminCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkAdminTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CanWorkAdminTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkAdminFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CanWorkAdminFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkAdminSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CanWorkAdminSession struct {
	Contract     *CanWorkAdmin     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CanWorkAdminCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CanWorkAdminCallerSession struct {
	Contract *CanWorkAdminCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// CanWorkAdminTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CanWorkAdminTransactorSession struct {
	Contract     *CanWorkAdminTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// CanWorkAdminRaw is an auto generated low-level Go binding around an Ethereum contract.
type CanWorkAdminRaw struct {
	Contract *CanWorkAdmin // Generic contract binding to access the raw methods on
}

// CanWorkAdminCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CanWorkAdminCallerRaw struct {
	Contract *CanWorkAdminCaller // Generic read-only contract binding to access the raw methods on
}

// CanWorkAdminTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CanWorkAdminTransactorRaw struct {
	Contract *CanWorkAdminTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCanWorkAdmin creates a new instance of CanWorkAdmin, bound to a specific deployed contract.
func NewCanWorkAdmin(address common.Address, backend bind.ContractBackend) (*CanWorkAdmin, error) {
	contract, err := bindCanWorkAdmin(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CanWorkAdmin{CanWorkAdminCaller: CanWorkAdminCaller{contract: contract}, CanWorkAdminTransactor: CanWorkAdminTransactor{contract: contract}, CanWorkAdminFilterer: CanWorkAdminFilterer{contract: contract}}, nil
}

// NewCanWorkAdminCaller creates a new read-only instance of CanWorkAdmin, bound to a specific deployed contract.
func NewCanWorkAdminCaller(address common.Address, caller bind.ContractCaller) (*CanWorkAdminCaller, error) {
	contract, err := bindCanWorkAdmin(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkAdminCaller{contract: contract}, nil
}

// NewCanWorkAdminTransactor creates a new write-only instance of CanWorkAdmin, bound to a specific deployed contract.
func NewCanWorkAdminTransactor(address common.Address, transactor bind.ContractTransactor) (*CanWorkAdminTransactor, error) {
	contract, err := bindCanWorkAdmin(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkAdminTransactor{contract: contract}, nil
}

// NewCanWorkAdminFilterer creates a new log filterer instance of CanWorkAdmin, bound to a specific deployed contract.
func NewCanWorkAdminFilterer(address common.Address, filterer bind.ContractFilterer) (*CanWorkAdminFilterer, error) {
	contract, err := bindCanWorkAdmin(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CanWorkAdminFilterer{contract: contract}, nil
}

// bindCanWorkAdmin binds a generic wrapper to an already deployed contract.
func bindCanWorkAdmin(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkAdminABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWorkAdmin *CanWorkAdminRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWorkAdmin.Contract.CanWorkAdminCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWorkAdmin *CanWorkAdminRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.CanWorkAdminTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWorkAdmin *CanWorkAdminRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.CanWorkAdminTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWorkAdmin *CanWorkAdminCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWorkAdmin.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWorkAdmin *CanWorkAdminTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWorkAdmin *CanWorkAdminTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.contract.Transact(opts, method, params...)
}

// GetSigner is a free data retrieval call binding the contract method 0x4fa6caf6.
//
// Solidity: function getSigner(id bytes32, index uint256) constant returns(address, bool)
func (_CanWorkAdmin *CanWorkAdminCaller) GetSigner(opts *bind.CallOpts, id [32]byte, index *big.Int) (common.Address, bool, error) {
	var (
		ret0 = new(common.Address)
		ret1 = new(bool)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _CanWorkAdmin.contract.Call(opts, out, "getSigner", id, index)
	return *ret0, *ret1, err
}

// GetSigner is a free data retrieval call binding the contract method 0x4fa6caf6.
//
// Solidity: function getSigner(id bytes32, index uint256) constant returns(address, bool)
func (_CanWorkAdmin *CanWorkAdminSession) GetSigner(id [32]byte, index *big.Int) (common.Address, bool, error) {
	return _CanWorkAdmin.Contract.GetSigner(&_CanWorkAdmin.CallOpts, id, index)
}

// GetSigner is a free data retrieval call binding the contract method 0x4fa6caf6.
//
// Solidity: function getSigner(id bytes32, index uint256) constant returns(address, bool)
func (_CanWorkAdmin *CanWorkAdminCallerSession) GetSigner(id [32]byte, index *big.Int) (common.Address, bool, error) {
	return _CanWorkAdmin.Contract.GetSigner(&_CanWorkAdmin.CallOpts, id, index)
}

// GetSignersCount is a free data retrieval call binding the contract method 0x46aaf139.
//
// Solidity: function getSignersCount(id bytes32) constant returns(uint8)
func (_CanWorkAdmin *CanWorkAdminCaller) GetSignersCount(opts *bind.CallOpts, id [32]byte) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _CanWorkAdmin.contract.Call(opts, out, "getSignersCount", id)
	return *ret0, err
}

// GetSignersCount is a free data retrieval call binding the contract method 0x46aaf139.
//
// Solidity: function getSignersCount(id bytes32) constant returns(uint8)
func (_CanWorkAdmin *CanWorkAdminSession) GetSignersCount(id [32]byte) (uint8, error) {
	return _CanWorkAdmin.Contract.GetSignersCount(&_CanWorkAdmin.CallOpts, id)
}

// GetSignersCount is a free data retrieval call binding the contract method 0x46aaf139.
//
// Solidity: function getSignersCount(id bytes32) constant returns(uint8)
func (_CanWorkAdmin *CanWorkAdminCallerSession) GetSignersCount(id [32]byte) (uint8, error) {
	return _CanWorkAdmin.Contract.GetSignersCount(&_CanWorkAdmin.CallOpts, id)
}

// HasRole is a free data retrieval call binding the contract method 0x217fe6c6.
//
// Solidity: function hasRole(addr address, roleName string) constant returns(bool)
func (_CanWorkAdmin *CanWorkAdminCaller) HasRole(opts *bind.CallOpts, addr common.Address, roleName string) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CanWorkAdmin.contract.Call(opts, out, "hasRole", addr, roleName)
	return *ret0, err
}

// HasRole is a free data retrieval call binding the contract method 0x217fe6c6.
//
// Solidity: function hasRole(addr address, roleName string) constant returns(bool)
func (_CanWorkAdmin *CanWorkAdminSession) HasRole(addr common.Address, roleName string) (bool, error) {
	return _CanWorkAdmin.Contract.HasRole(&_CanWorkAdmin.CallOpts, addr, roleName)
}

// HasRole is a free data retrieval call binding the contract method 0x217fe6c6.
//
// Solidity: function hasRole(addr address, roleName string) constant returns(bool)
func (_CanWorkAdmin *CanWorkAdminCallerSession) HasRole(addr common.Address, roleName string) (bool, error) {
	return _CanWorkAdmin.Contract.HasRole(&_CanWorkAdmin.CallOpts, addr, roleName)
}

// AddSig is a paid mutator transaction binding the contract method 0xe287adf4.
//
// Solidity: function addSig(signer address, id bytes32) returns(uint8)
func (_CanWorkAdmin *CanWorkAdminTransactor) AddSig(opts *bind.TransactOpts, signer common.Address, id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.contract.Transact(opts, "addSig", signer, id)
}

// AddSig is a paid mutator transaction binding the contract method 0xe287adf4.
//
// Solidity: function addSig(signer address, id bytes32) returns(uint8)
func (_CanWorkAdmin *CanWorkAdminSession) AddSig(signer common.Address, id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.AddSig(&_CanWorkAdmin.TransactOpts, signer, id)
}

// AddSig is a paid mutator transaction binding the contract method 0xe287adf4.
//
// Solidity: function addSig(signer address, id bytes32) returns(uint8)
func (_CanWorkAdmin *CanWorkAdminTransactorSession) AddSig(signer common.Address, id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.AddSig(&_CanWorkAdmin.TransactOpts, signer, id)
}

// ResetSignature is a paid mutator transaction binding the contract method 0x5969c0e1.
//
// Solidity: function resetSignature(id bytes32) returns(bool)
func (_CanWorkAdmin *CanWorkAdminTransactor) ResetSignature(opts *bind.TransactOpts, id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.contract.Transact(opts, "resetSignature", id)
}

// ResetSignature is a paid mutator transaction binding the contract method 0x5969c0e1.
//
// Solidity: function resetSignature(id bytes32) returns(bool)
func (_CanWorkAdmin *CanWorkAdminSession) ResetSignature(id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.ResetSignature(&_CanWorkAdmin.TransactOpts, id)
}

// ResetSignature is a paid mutator transaction binding the contract method 0x5969c0e1.
//
// Solidity: function resetSignature(id bytes32) returns(bool)
func (_CanWorkAdmin *CanWorkAdminTransactorSession) ResetSignature(id [32]byte) (*types.Transaction, error) {
	return _CanWorkAdmin.Contract.ResetSignature(&_CanWorkAdmin.TransactOpts, id)
}

// CanWorkJobABI is the input ABI used to generate the binding from.
const CanWorkJobABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"cancelJobByProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrow\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"closedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"updatePriceOracleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_OWNER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"completeJob\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_payToClientPercentage\",\"type\":\"uint8\"},{\"name\":\"_payToProviderPercentage\",\"type\":\"uint8\"},{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_payToArbiterPercentage\",\"type\":\"uint8\"}],\"name\":\"cancelJobByAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"getJobPayments\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"valueInDai\",\"type\":\"uint256\"},{\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"name\":\"paidToDappAmount\",\"type\":\"uint256\"},{\"name\":\"paidToProviderAmount\",\"type\":\"uint256\"},{\"name\":\"paidToClientAmount\",\"type\":\"uint256\"},{\"name\":\"paidToArbiterAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"isMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_ADMIN\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"},{\"name\":\"_client\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"},{\"name\":\"_totalCosts\",\"type\":\"uint256\"}],\"name\":\"createJob\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"getJob\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"valueInDai\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"closedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_canworkAdmin\",\"type\":\"address\"},{\"name\":\"_dApp\",\"type\":\"address\"},{\"name\":\"_priceOracle\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrowPayments\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"name\":\"paidToDappAmount\",\"type\":\"uint256\"},{\"name\":\"paidToProviderAmount\",\"type\":\"uint256\"},{\"name\":\"paidToClientAmount\",\"type\":\"uint256\"},{\"name\":\"paidToArbiterAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalCosts\",\"type\":\"uint256\"}],\"name\":\"OnCreateJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"OnCompleteJob\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"}],\"name\":\"OnCancelJobByProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"jobId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"payToProviderPercentage\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payToArbiterPercentage\",\"type\":\"uint8\"}],\"name\":\"OnCancelJobByAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dApp\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceOracle\",\"type\":\"address\"}],\"name\":\"OnInitialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"OnCreateEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCompleteEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrowByProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payToProviderAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payToArbiterAmount\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"Migrated\",\"type\":\"event\"}]"

// CanWorkJobBin is the compiled bytecode used for deploying new contracts.
const CanWorkJobBin = `0x6080604052600060025534801561001557600080fd5b50612b3d806100256000396000f3006080604052600436106100cf5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632630c12f81146100d45780636e6bfca0146101055780637d19e5961461013157806386d1e02b146101905780638ad682af146101b3578063991e01391461023d578063a52c7a4f14610255578063afcfad6e1461028c578063c0bac1a8146102dc578063d391014b14610373578063e7acaa1e14610388578063f729cf0d146103b5578063f8c8765e146103cd578063fd232b5914610400575b600080fd5b3480156100e057600080fd5b506100e9610418565b60408051600160a060020a039092168252519081900360200190f35b34801561011157600080fd5b5061011d600435610427565b604080519115158252519081900360200190f35b34801561013d57600080fd5b50610149600435610518565b60408051600160a060020a03988916815296909716602087015285870194909452606085019290925260ff16608084015260a083015260c082015290519081900360e00190f35b34801561019c57600080fd5b506101b1600160a060020a0360043516610613565b005b3480156101bf57600080fd5b506101c8610819565b6040805160208082528351818301528351919283929083019185019080838360005b838110156102025781810151838201526020016101ea565b50505050905090810190601f16801561022f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561024957600080fd5b5061011d600435610850565b34801561026157600080fd5b5061011d60043560ff602435811690604435811690600160a060020a03606435169060843516610941565b34801561029857600080fd5b506102a4600435610c37565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b3480156102e857600080fd5b506040805160206004803580820135601f810184900484028501840190955284845261011d94369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a999881019791965091820194509250829150840183828082843750949750610d519650505050505050565b34801561037f57600080fd5b506101c8610e1a565b34801561039457600080fd5b5061011d600435600160a060020a0360243581169060443516606435610e51565b3480156103c157600080fd5b50610149600435610f7a565b3480156103d957600080fd5b506101b1600160a060020a036004358116906024358116906044358116906064351661107d565b34801561040c57600080fd5b506102a4600435611370565b600554600160a060020a031681565b6000600160f860020a031960f860020a83831a0216151561044757600080fd5b60008281526008602052604081206004015460ff16600281111561046757fe5b1461047157600080fd5b600082815260086020526040902060020154600160a060020a0316331461049757600080fd5b6000828152600860205260409020600301546104b290611436565b15156104bd57600080fd5b600082815260086020526040808220600401805460ff1916600217905560095490518492600160a060020a03909216917f9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c42691a3506001919050565b600080600080600080600080881180156105415750600088815260066020819052604082200154115b1515610597576040805160e560020a62461bcd02815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b6000888152600660205260409020600181015460028083015460038401546004850154600590950154600160a060020a03948516959290941693909260ff909116908111156105e257fe5b60009c8d52600660208190526040909d209c8d01546007909d0154949d939c929b5090995097509550909350915050565b600160a060020a038116158015906106395750600554600160a060020a03828116911614155b151561068f576040805160e560020a62461bcd02815260206004820152601a60248201527f4d7573742062652076616c69642c206e65772061646472657373000000000000604482015290519081900360640190fd5b600754604080518082018252600581527f6f776e65720000000000000000000000000000000000000000000000000000006020820190815282517f217fe6c6000000000000000000000000000000000000000000000000000000008152336004820181815260248301958652845160448401528451600160a060020a039097169663217fe6c6969295949193606401919080838360005b8381101561073e578181015183820152602001610726565b50505050905090810190601f16801561076b5780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b15801561078b57600080fd5b505af115801561079f573d6000803e3d6000fd5b505050506040513d60208110156107b557600080fd5b5051151561080d576040805160e560020a62461bcd02815260206004820152601560248201527f4f6e6c79206f776e65722063616e207570646174650000000000000000000000604482015290519081900360640190fd5b6108168161169a565b50565b60408051808201909152600581527f6f776e6572000000000000000000000000000000000000000000000000000000602082015281565b6000600160f860020a031960f860020a83831a0216151561087057600080fd5b60008281526008602052604081206004015460ff16600281111561089057fe5b1461089a57600080fd5b600082815260086020526040902060010154600160a060020a031633146108c057600080fd5b6000828152600860205260409020600301546108db906116c9565b15156108e657600080fd5b600082815260086020526040808220600401805460ff1916600117905560095490518492600160a060020a03909216917f5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a91a3506001919050565b6000600160f860020a031960f860020a87831a021615156109ac576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b60008681526008602052604081206004015460ff1660028111156109cc57fe5b146109d657600080fd5b600754604080518082018252600581527f61646d696e0000000000000000000000000000000000000000000000000000006020820190815282517f217fe6c6000000000000000000000000000000000000000000000000000000008152336004820181815260248301958652845160448401528451600160a060020a039097169663217fe6c6969295949193606401919080838360005b83811015610a85578181015183820152602001610a6d565b50505050905090810190601f168015610ab25780820380516001836020036101000a031916815260200191505b509350505050602060405180830381600087803b158015610ad257600080fd5b505af1158015610ae6573d6000803e3d6000fd5b505050506040513d6020811015610afc57600080fd5b50511515610b0957600080fd5b600560ff83161115610b8b576040805160e560020a62461bcd02815260206004820152602c60248201527f417262697465722063616e6e6f742072656365697665206d6f7265207468616e60448201527f203525206f662066756e64730000000000000000000000000000000000000000606482015290519081900360840190fd5b600086815260086020526040902060030154610baa9086868686611ab9565b1515610bb557600080fd5b600086815260086020526040902060040180546002919060ff191660018302179055506009546040805160ff8088168252851660208201528151600160a060020a03808816948b949116927fb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611929081900390910190a450600195945050505050565b6000808080808080600160f860020a031960f860020a89831a02161515610ca8576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040812054901a60f860020a02600160f860020a0319161515610d1f576040805160e560020a62461bcd02815260206004820152600e60248201527f4a6f62206d757374206578697374000000000000000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040902060030154610d3a90611370565b959e949d50929b5090995097509550909350915050565b600080836040518082805190602001908083835b60208310610d845780518252601f199092019160209182019101610d65565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b60208310610de05780518252601f199092019160209182019101610dc1565b51815160209384036101000a600019018019909216911617905292019485525060405193849003019092205460ff16925050505b92915050565b60408051808201909152600581527f61646d696e000000000000000000000000000000000000000000000000000000602082015281565b6000600160f860020a031960f860020a86831a02161515610e7157600080fd5b600085815260086020526040812054901a60f860020a02600160f860020a03191615610e9c57600080fd5b6000858152600860205260409020858155600181018054600160a060020a0387811673ffffffffffffffffffffffffffffffffffffffff19928316179092556002830180549287169290911691909117905560048101805460ff19169055600501829055610f0b848484612219565b600086815260086020908152604091829020600301929092556009548151600160a060020a0388811682529381018690528251848816948a949316927f06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e928290030190a4506001949350505050565b6000808080808080600160f860020a031960f860020a89831a02161515610feb576040805160e560020a62461bcd02815260206004820152601360248201527f4d7573742062652076616c6964206a6f62496400000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040812054901a60f860020a02600160f860020a0319161515611062576040805160e560020a62461bcd02815260206004820152600e60248201527f4a6f62206d757374206578697374000000000000000000000000000000000000604482015290519081900360640190fd5b600088815260086020526040902060030154610d3a90610518565b6040805190810160405280600a81526020017f43616e576f726b4a6f62000000000000000000000000000000000000000000008152506040805190810160405280600581526020017f302e312e330000000000000000000000000000000000000000000000000000008152506110f38282610d51565b156110fd57600080fd5b600160a060020a0386161580159061111d5750600160a060020a03851615155b80156111315750600160a060020a03841615155b80156111455750600160a060020a03831615155b151561115057600080fd5b61115b8685856125de565b60078054600160a060020a0380881673ffffffffffffffffffffffffffffffffffffffff199283161790925560098054928716929091169190911790556040805181815283519181019190915282517fdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea39184918491908190602080830191606084019187019080838360005b838110156111ff5781810151838201526020016111e7565b50505050905090810190601f16801561122c5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561125f578181015183820152602001611247565b50505050905090810190601f16801561128c5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a160016000836040518082805190602001908083835b602083106112cf5780518252601f1990920191602091820191016112b0565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b6020831061132b5780518252601f19909201916020918201910161130c565b51815160209384036101000a60001901801990921691161790529201948552506040519384900301909220805460ff1916931515939093179092555050505050505050565b600080600080600080600080881180156113995750600088815260066020819052604082200154115b15156113ef576040805160e560020a62461bcd02815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b5050506000948552505060066020525050604090206003810154600482015460088301546009840154600a850154600b860154600c90960154949693959294919390929190565b60008060008381526006602052604090206005015460ff16600281111561145957fe5b146114ae576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b600082815260066020526040902060020154600160a060020a03163314611544576040805160e560020a62461bcd028152602060048201526024808201527f5472616e73616374696f6e206d7573742062652073656e742062792070726f7660448201527f6964657200000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b61154d82612942565b600083815260066020908152604080832060088101859055600b810185905560058101805460ff1916600217905543600782015560018054910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b1580156115d857600080fd5b505af11580156115ec573d6000803e3d6000fd5b505050506040513d602081101561160257600080fd5b5051151561165a576040805160e560020a62461bcd02815260206004820152601b60248201527f436c69656e74206d7573742072656365697665207061796d656e740000000000604482015290519081900360640190fd5b6003546040518391600160a060020a0316907f42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd672690600090a3506001919050565b6005805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b600080808060008581526006602052604090206005015460ff1660028111156116ee57fe5b14611743576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b600084815260066020526040902060010154600160a060020a031633146117da576040805160e560020a62461bcd02815260206004820152602660248201527f5472616e73616374696f6e206d7573742062652073656e74206279207468652060448201527f636c69656e740000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600084815260066020526040902060058101805460ff191660011790554360079091015561180784612942565b600085815260066020526040902060080181905560045461184191606491611835919063ffffffff612ac116565b9063ffffffff612aea16565b9150600082111561193c576000848152600660209081526040808320600901859055600154600354825160e060020a63a9059cbb028152600160a060020a03918216600482015260248101889052925191169363a9059cbb93604480850194919392918390030190829087803b1580156118ba57600080fd5b505af11580156118ce573d6000803e3d6000fd5b505050506040513d60208110156118e457600080fd5b5051151561193c576040805160e560020a62461bcd02815260206004820152601960248201527f44617070206d7573742072656365697665207061796d656e7400000000000000604482015290519081900360640190fd5b60008481526006602052604090206008015461195e908363ffffffff612aff16565b6000858152600660209081526040808320600a8101859055600154600290910154825160e060020a63a9059cbb028152600160a060020a039182166004820152602481018790529251959650169363a9059cbb93604480840194938390030190829087803b1580156119cf57600080fd5b505af11580156119e3573d6000803e3d6000fd5b505050506040513d60208110156119f957600080fd5b50511515611a77576040805160e560020a62461bcd02815260206004820152602660248201527f457363726f77206d75737420686f6c6420656e6f7567682043414e20666f722060448201527f7061796f75740000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b6003546040518591600160a060020a0316907f4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a90600090a35060019392505050565b600080808060008981526006602052604090206005015460ff166002811115611ade57fe5b14611b33576040805160e560020a62461bcd02815260206004820152601b60248201527f457363726f7720737461747573206d75737420626520276e6577270000000000604482015290519081900360640190fd5b60008760ff1610158015611b4b575060008660ff1610155b8015611b5b575060008460ff1610155b8015611b6b575060648760ff1611155b8015611b7b575060648660ff1611155b8015611b8b575060648460ff1611155b1515611c07576040805160e560020a62461bcd02815260206004820152603660248201527f5061796d656e747320746f20636c69656e742c2070726f766964657220616e6460448201527f2061726269746572206d75737420626520677465203000000000000000000000606482015290519081900360840190fd5b606460ff88880186011614611c8c576040805160e560020a62461bcd02815260206004820152602360248201527f546f74616c207061796f7574206d75737420657175616c20313030207065726360448201527f656e740000000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600088815260066020526040902060058101805460ff1916600217905543600790910155611cb988612942565b6000898152600660205260409020600801819055600454611ce791606491611835919063ffffffff612ac116565b91506000821115611de2576000888152600660209081526040808320600901859055600154600354825160e060020a63a9059cbb028152600160a060020a03918216600482015260248101889052925191169363a9059cbb93604480850194919392918390030190829087803b158015611d6057600080fd5b505af1158015611d74573d6000803e3d6000fd5b505050506040513d6020811015611d8a57600080fd5b50511515611de2576040805160e560020a62461bcd02815260206004820152601960248201527f44617070206d7573742072656365697665207061796d656e7400000000000000604482015290519081900360640190fd5b600088815260066020526040902060080154611e04908363ffffffff612aff16565b905060008460ff161115611f7557600160a060020a0385161515611e72576040805160e560020a62461bcd02815260206004820152601d60248201527f417262697465722061646472657373206d7573742062652076616c6964000000604482015290519081900360640190fd5b611e8a60646118358360ff881663ffffffff612ac116565b6000898152600660209081526040808320600c01849055600154815160e060020a63a9059cbb028152600160a060020a038b811660048301526024820196909652915194169363a9059cbb93604480840194938390030190829087803b158015611ef357600080fd5b505af1158015611f07573d6000803e3d6000fd5b505050506040513d6020811015611f1d57600080fd5b50511515611f75576040805160e560020a62461bcd02815260206004820152601c60248201527f41726269746572206d7573742072656365697665207061796d656e7400000000604482015290519081900360640190fd5b60008660ff16111561208c57611f9960646118358360ff8a1663ffffffff612ac116565b6000898152600660209081526040808320600a8101859055600154600290910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b15801561200a57600080fd5b505af115801561201e573d6000803e3d6000fd5b505050506040513d602081101561203457600080fd5b5051151561208c576040805160e560020a62461bcd02815260206004820152601d60248201527f50726f7669646572206d7573742072656365697665207061796d656e74000000604482015290519081900360640190fd5b60008760ff1611156121a1576120b060646118358360ff8b1663ffffffff612ac116565b6000898152600660209081526040808320600b810185905560018054910154825160e060020a63a9059cbb028152600160a060020a0391821660048201526024810196909652915191169363a9059cbb9360448083019493928390030190829087803b15801561211f57600080fd5b505af1158015612133573d6000803e3d6000fd5b505050506040513d602081101561214957600080fd5b505115156121a1576040805160e560020a62461bcd02815260206004820152601b60248201527f436c69656e74206d7573742072656365697665207061796d656e740000000000604482015290519081900360640190fd5b600354600089815260066020908152604091829020600a810154600c909101548351918252918101919091528151600160a060020a03808a16948d949116927f23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b929081900390910190a4506001979650505050505050565b6000808080600160a060020a0387161580159061223e5750600160a060020a03861615155b801561224a5750600085115b15156122c6576040805160e560020a62461bcd02815260206004820152602e60248201527f4d75737420626520612076616c69642061646472657373657320616e64206e6f60448201527f6e207a65726f20616d6f756e7473000000000000000000000000000000000000606482015290519081900360840190fd5b600154604080517f23b872dd000000000000000000000000000000000000000000000000000000008152600160a060020a038a8116600483015230602483015260448201899052915191909216916323b872dd9160648083019260209291908290030181600087803b15801561233b57600080fd5b505af115801561234f573d6000803e3d6000fd5b505050506040513d602081101561236557600080fd5b505115156123e3576040805160e560020a62461bcd02815260206004820152603a60248201527f436c69656e74206d757374206861766520617574686f7269736174696f6e206160448201527f6e642062616c616e636520746f207472616e736665722043414e000000000000606482015290519081900360840190fd5b600554604080517f9fd650ce000000000000000000000000000000000000000000000000000000008152600481018890529051600160a060020a0390921691639fd650ce916024808201926020929091908290030181600087803b15801561244a57600080fd5b505af115801561245e573d6000803e3d6000fd5b505050506040513d602081101561247457600080fd5b50519250600083116124f5576040805160e560020a62461bcd028152602060048201526024808201527f4a6f622076616c7565206d7573742062652067726561746572207468616e203060448201527f2055534400000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b505060028054600190810180835560008181526006602081815260408084208581559586018054600160a060020a038e811673ffffffffffffffffffffffffffffffffffffffff19928316811790935598880180548e8b1692168217905560038089018d9055600489018b9055439589019590955560058801805460ff1916905560088801869055600a8801869055600b8801869055600c880195909555925481518b8152928301899052815195979495939416927f2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb9281900390910190a45095945050505050565b6040805190810160405280600681526020017f457363726f7700000000000000000000000000000000000000000000000000008152506040805190810160405280600581526020017f302e312e330000000000000000000000000000000000000000000000000000008152506126548282610d51565b1561265e57600080fd5b600160a060020a0385161580159061267e5750600160a060020a03841615155b80156126925750600160a060020a03831615155b15156126e8576040805160e560020a62461bcd02815260206004820152601760248201527f4d7573742062652076616c696420616464726573736573000000000000000000604482015290519081900360640190fd5b60018054600160a060020a0380881673ffffffffffffffffffffffffffffffffffffffff19928316811784556003805489841690851681179091556005805493891693909416831790935560049390935560408051918252519192917f92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff09181900360200190a37fdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea38282604051808060200180602001838103835285818151815260200191508051906020019080838360005b838110156127d25781810151838201526020016127ba565b50505050905090810190601f1680156127ff5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561283257818101518382015260200161281a565b50505050905090810190601f16801561285f5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a160016000836040518082805190602001908083835b602083106128a25780518252601f199092019160209182019101612883565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b602083106128fe5780518252601f1990920191602091820191016128df565b51815160209384036101000a60001901801990921691161790529201948552506040519384900301909220805460ff19169315159390931790925550505050505050565b600554600082815260066020908152604080832060049081015482517fc8a1d96e00000000000000000000000000000000000000000000000000000000815291820152905192938493600160a060020a039091169263c8a1d96e926024808201939182900301818787803b1580156129b957600080fd5b505af11580156129cd573d6000803e3d6000fd5b505050506040513d60208110156129e357600080fd5b5051905060008111612a64576040805160e560020a62461bcd028152602060048201526024808201527f4f7261636c65206d7573742072657475726e2061206e6f6e207a65726f20706160448201527f796f757400000000000000000000000000000000000000000000000000000000606482015290519081900360840190fd5b600083815260066020526040902060030154612a8790600263ffffffff612ac116565b8110612ab757600083815260066020526040902060030154612ab090600263ffffffff612ac116565b9150612abb565b8091505b50919050565b6000821515612ad257506000610e14565b50818102818382811515612ae257fe5b0414610e1457fe5b60008183811515612af757fe5b049392505050565b600082821115612b0b57fe5b509003905600a165627a7a72305820afe709b2f4ee9e444cbf35fbb422221dae4606a9d5dcd2b7fd239673e933fbca0029`

// DeployCanWorkJob deploys a new Ethereum contract, binding an instance of CanWorkJob to it.
func DeployCanWorkJob(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CanWorkJob, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkJobABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CanWorkJobBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CanWorkJob{CanWorkJobCaller: CanWorkJobCaller{contract: contract}, CanWorkJobTransactor: CanWorkJobTransactor{contract: contract}, CanWorkJobFilterer: CanWorkJobFilterer{contract: contract}}, nil
}

// CanWorkJob is an auto generated Go binding around an Ethereum contract.
type CanWorkJob struct {
	CanWorkJobCaller     // Read-only binding to the contract
	CanWorkJobTransactor // Write-only binding to the contract
	CanWorkJobFilterer   // Log filterer for contract events
}

// CanWorkJobCaller is an auto generated read-only Go binding around an Ethereum contract.
type CanWorkJobCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkJobTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CanWorkJobTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkJobFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CanWorkJobFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CanWorkJobSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CanWorkJobSession struct {
	Contract     *CanWorkJob       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CanWorkJobCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CanWorkJobCallerSession struct {
	Contract *CanWorkJobCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// CanWorkJobTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CanWorkJobTransactorSession struct {
	Contract     *CanWorkJobTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// CanWorkJobRaw is an auto generated low-level Go binding around an Ethereum contract.
type CanWorkJobRaw struct {
	Contract *CanWorkJob // Generic contract binding to access the raw methods on
}

// CanWorkJobCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CanWorkJobCallerRaw struct {
	Contract *CanWorkJobCaller // Generic read-only contract binding to access the raw methods on
}

// CanWorkJobTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CanWorkJobTransactorRaw struct {
	Contract *CanWorkJobTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCanWorkJob creates a new instance of CanWorkJob, bound to a specific deployed contract.
func NewCanWorkJob(address common.Address, backend bind.ContractBackend) (*CanWorkJob, error) {
	contract, err := bindCanWorkJob(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CanWorkJob{CanWorkJobCaller: CanWorkJobCaller{contract: contract}, CanWorkJobTransactor: CanWorkJobTransactor{contract: contract}, CanWorkJobFilterer: CanWorkJobFilterer{contract: contract}}, nil
}

// NewCanWorkJobCaller creates a new read-only instance of CanWorkJob, bound to a specific deployed contract.
func NewCanWorkJobCaller(address common.Address, caller bind.ContractCaller) (*CanWorkJobCaller, error) {
	contract, err := bindCanWorkJob(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobCaller{contract: contract}, nil
}

// NewCanWorkJobTransactor creates a new write-only instance of CanWorkJob, bound to a specific deployed contract.
func NewCanWorkJobTransactor(address common.Address, transactor bind.ContractTransactor) (*CanWorkJobTransactor, error) {
	contract, err := bindCanWorkJob(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobTransactor{contract: contract}, nil
}

// NewCanWorkJobFilterer creates a new log filterer instance of CanWorkJob, bound to a specific deployed contract.
func NewCanWorkJobFilterer(address common.Address, filterer bind.ContractFilterer) (*CanWorkJobFilterer, error) {
	contract, err := bindCanWorkJob(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobFilterer{contract: contract}, nil
}

// bindCanWorkJob binds a generic wrapper to an already deployed contract.
func bindCanWorkJob(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CanWorkJobABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWorkJob *CanWorkJobRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWorkJob.Contract.CanWorkJobCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWorkJob *CanWorkJobRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CanWorkJobTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWorkJob *CanWorkJobRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CanWorkJobTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CanWorkJob *CanWorkJobCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CanWorkJob.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CanWorkJob *CanWorkJobTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CanWorkJob.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CanWorkJob *CanWorkJobTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CanWorkJob.Contract.contract.Transact(opts, method, params...)
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWorkJob *CanWorkJobCaller) ROLEADMIN(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CanWorkJob.contract.Call(opts, out, "ROLE_ADMIN")
	return *ret0, err
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWorkJob *CanWorkJobSession) ROLEADMIN() (string, error) {
	return _CanWorkJob.Contract.ROLEADMIN(&_CanWorkJob.CallOpts)
}

// ROLEADMIN is a free data retrieval call binding the contract method 0xd391014b.
//
// Solidity: function ROLE_ADMIN() constant returns(string)
func (_CanWorkJob *CanWorkJobCallerSession) ROLEADMIN() (string, error) {
	return _CanWorkJob.Contract.ROLEADMIN(&_CanWorkJob.CallOpts)
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWorkJob *CanWorkJobCaller) ROLEOWNER(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CanWorkJob.contract.Call(opts, out, "ROLE_OWNER")
	return *ret0, err
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWorkJob *CanWorkJobSession) ROLEOWNER() (string, error) {
	return _CanWorkJob.Contract.ROLEOWNER(&_CanWorkJob.CallOpts)
}

// ROLEOWNER is a free data retrieval call binding the contract method 0x8ad682af.
//
// Solidity: function ROLE_OWNER() constant returns(string)
func (_CanWorkJob *CanWorkJobCallerSession) ROLEOWNER() (string, error) {
	return _CanWorkJob.Contract.ROLEOWNER(&_CanWorkJob.CallOpts)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobCaller) GetEscrow(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	ret := new(struct {
		Client        common.Address
		Provider      common.Address
		Amount        *big.Int
		TotalValueDai *big.Int
		Status        uint8
		CreatedAt     *big.Int
		ClosedAt      *big.Int
	})
	out := ret
	err := _CanWorkJob.contract.Call(opts, out, "getEscrow", _escrowId)
	return *ret, err
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _CanWorkJob.Contract.GetEscrow(&_CanWorkJob.CallOpts, _escrowId)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobCallerSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _CanWorkJob.Contract.GetEscrow(&_CanWorkJob.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobCaller) GetEscrowPayments(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	ret := new(struct {
		Amount               *big.Int
		TotalValueDai        *big.Int
		PayoutAmount         *big.Int
		PaidToDappAmount     *big.Int
		PaidToProviderAmount *big.Int
		PaidToClientAmount   *big.Int
		PaidToArbiterAmount  *big.Int
	})
	out := ret
	err := _CanWorkJob.contract.Call(opts, out, "getEscrowPayments", _escrowId)
	return *ret, err
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWorkJob.Contract.GetEscrowPayments(&_CanWorkJob.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobCallerSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWorkJob.Contract.GetEscrowPayments(&_CanWorkJob.CallOpts, _escrowId)
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobCaller) GetJob(opts *bind.CallOpts, _jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	ret := new(struct {
		Client     common.Address
		Provider   common.Address
		Amount     *big.Int
		ValueInDai *big.Int
		Status     uint8
		CreatedAt  *big.Int
		ClosedAt   *big.Int
	})
	out := ret
	err := _CanWorkJob.contract.Call(opts, out, "getJob", _jobId)
	return *ret, err
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobSession) GetJob(_jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	return _CanWorkJob.Contract.GetJob(&_CanWorkJob.CallOpts, _jobId)
}

// GetJob is a free data retrieval call binding the contract method 0xf729cf0d.
//
// Solidity: function getJob(_jobId bytes32) constant returns(client address, provider address, amount uint256, valueInDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_CanWorkJob *CanWorkJobCallerSession) GetJob(_jobId [32]byte) (struct {
	Client     common.Address
	Provider   common.Address
	Amount     *big.Int
	ValueInDai *big.Int
	Status     uint8
	CreatedAt  *big.Int
	ClosedAt   *big.Int
}, error) {
	return _CanWorkJob.Contract.GetJob(&_CanWorkJob.CallOpts, _jobId)
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobCaller) GetJobPayments(opts *bind.CallOpts, _jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	ret := new(struct {
		Amount               *big.Int
		ValueInDai           *big.Int
		PayoutAmount         *big.Int
		PaidToDappAmount     *big.Int
		PaidToProviderAmount *big.Int
		PaidToClientAmount   *big.Int
		PaidToArbiterAmount  *big.Int
	})
	out := ret
	err := _CanWorkJob.contract.Call(opts, out, "getJobPayments", _jobId)
	return *ret, err
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobSession) GetJobPayments(_jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWorkJob.Contract.GetJobPayments(&_CanWorkJob.CallOpts, _jobId)
}

// GetJobPayments is a free data retrieval call binding the contract method 0xafcfad6e.
//
// Solidity: function getJobPayments(_jobId bytes32) constant returns(amount uint256, valueInDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobCallerSession) GetJobPayments(_jobId [32]byte) (struct {
	Amount               *big.Int
	ValueInDai           *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _CanWorkJob.Contract.GetJobPayments(&_CanWorkJob.CallOpts, _jobId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWorkJob *CanWorkJobCaller) IsMigrated(opts *bind.CallOpts, contractName string, migrationId string) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CanWorkJob.contract.Call(opts, out, "isMigrated", contractName, migrationId)
	return *ret0, err
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWorkJob *CanWorkJobSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _CanWorkJob.Contract.IsMigrated(&_CanWorkJob.CallOpts, contractName, migrationId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_CanWorkJob *CanWorkJobCallerSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _CanWorkJob.Contract.IsMigrated(&_CanWorkJob.CallOpts, contractName, migrationId)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWorkJob *CanWorkJobCaller) PriceOracle(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CanWorkJob.contract.Call(opts, out, "priceOracle")
	return *ret0, err
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWorkJob *CanWorkJobSession) PriceOracle() (common.Address, error) {
	return _CanWorkJob.Contract.PriceOracle(&_CanWorkJob.CallOpts)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_CanWorkJob *CanWorkJobCallerSession) PriceOracle() (common.Address, error) {
	return _CanWorkJob.Contract.PriceOracle(&_CanWorkJob.CallOpts)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWorkJob *CanWorkJobTransactor) CancelJobByAdmin(opts *bind.TransactOpts, _jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "cancelJobByAdmin", _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWorkJob *CanWorkJobSession) CancelJobByAdmin(_jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CancelJobByAdmin(&_CanWorkJob.TransactOpts, _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByAdmin is a paid mutator transaction binding the contract method 0xa52c7a4f.
//
// Solidity: function cancelJobByAdmin(_jobId bytes32, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter address, _payToArbiterPercentage uint8) returns(bool)
func (_CanWorkJob *CanWorkJobTransactorSession) CancelJobByAdmin(_jobId [32]byte, _payToClientPercentage uint8, _payToProviderPercentage uint8, _arbiter common.Address, _payToArbiterPercentage uint8) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CancelJobByAdmin(&_CanWorkJob.TransactOpts, _jobId, _payToClientPercentage, _payToProviderPercentage, _arbiter, _payToArbiterPercentage)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobTransactor) CancelJobByProvider(opts *bind.TransactOpts, _jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "cancelJobByProvider", _jobId)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobSession) CancelJobByProvider(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CancelJobByProvider(&_CanWorkJob.TransactOpts, _jobId)
}

// CancelJobByProvider is a paid mutator transaction binding the contract method 0x6e6bfca0.
//
// Solidity: function cancelJobByProvider(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobTransactorSession) CancelJobByProvider(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CancelJobByProvider(&_CanWorkJob.TransactOpts, _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobTransactor) CompleteJob(opts *bind.TransactOpts, _jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "completeJob", _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobSession) CompleteJob(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CompleteJob(&_CanWorkJob.TransactOpts, _jobId)
}

// CompleteJob is a paid mutator transaction binding the contract method 0x991e0139.
//
// Solidity: function completeJob(_jobId bytes32) returns(bool)
func (_CanWorkJob *CanWorkJobTransactorSession) CompleteJob(_jobId [32]byte) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CompleteJob(&_CanWorkJob.TransactOpts, _jobId)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWorkJob *CanWorkJobTransactor) CreateJob(opts *bind.TransactOpts, _jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "createJob", _jobId, _client, _provider, _totalCosts)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWorkJob *CanWorkJobSession) CreateJob(_jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CreateJob(&_CanWorkJob.TransactOpts, _jobId, _client, _provider, _totalCosts)
}

// CreateJob is a paid mutator transaction binding the contract method 0xe7acaa1e.
//
// Solidity: function createJob(_jobId bytes32, _client address, _provider address, _totalCosts uint256) returns(bool)
func (_CanWorkJob *CanWorkJobTransactorSession) CreateJob(_jobId [32]byte, _client common.Address, _provider common.Address, _totalCosts *big.Int) (*types.Transaction, error) {
	return _CanWorkJob.Contract.CreateJob(&_CanWorkJob.TransactOpts, _jobId, _client, _provider, _totalCosts)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWorkJob *CanWorkJobTransactor) Initialize(opts *bind.TransactOpts, _token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "initialize", _token, _canworkAdmin, _dApp, _priceOracle)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWorkJob *CanWorkJobSession) Initialize(_token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.Contract.Initialize(&_CanWorkJob.TransactOpts, _token, _canworkAdmin, _dApp, _priceOracle)
}

// Initialize is a paid mutator transaction binding the contract method 0xf8c8765e.
//
// Solidity: function initialize(_token address, _canworkAdmin address, _dApp address, _priceOracle address) returns()
func (_CanWorkJob *CanWorkJobTransactorSession) Initialize(_token common.Address, _canworkAdmin common.Address, _dApp common.Address, _priceOracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.Contract.Initialize(&_CanWorkJob.TransactOpts, _token, _canworkAdmin, _dApp, _priceOracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWorkJob *CanWorkJobTransactor) UpdatePriceOracleAddress(opts *bind.TransactOpts, _oracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.contract.Transact(opts, "updatePriceOracleAddress", _oracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWorkJob *CanWorkJobSession) UpdatePriceOracleAddress(_oracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.Contract.UpdatePriceOracleAddress(&_CanWorkJob.TransactOpts, _oracle)
}

// UpdatePriceOracleAddress is a paid mutator transaction binding the contract method 0x86d1e02b.
//
// Solidity: function updatePriceOracleAddress(_oracle address) returns()
func (_CanWorkJob *CanWorkJobTransactorSession) UpdatePriceOracleAddress(_oracle common.Address) (*types.Transaction, error) {
	return _CanWorkJob.Contract.UpdatePriceOracleAddress(&_CanWorkJob.TransactOpts, _oracle)
}

// CanWorkJobMigratedIterator is returned from FilterMigrated and is used to iterate over the raw logs and unpacked data for Migrated events raised by the CanWorkJob contract.
type CanWorkJobMigratedIterator struct {
	Event *CanWorkJobMigrated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobMigratedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobMigrated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobMigrated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobMigratedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobMigratedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobMigrated represents a Migrated event raised by the CanWorkJob contract.
type CanWorkJobMigrated struct {
	ContractName string
	MigrationId  string
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterMigrated is a free log retrieval operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_CanWorkJob *CanWorkJobFilterer) FilterMigrated(opts *bind.FilterOpts) (*CanWorkJobMigratedIterator, error) {

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return &CanWorkJobMigratedIterator{contract: _CanWorkJob.contract, event: "Migrated", logs: logs, sub: sub}, nil
}

// WatchMigrated is a free log subscription operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_CanWorkJob *CanWorkJobFilterer) WatchMigrated(opts *bind.WatchOpts, sink chan<- *CanWorkJobMigrated) (event.Subscription, error) {

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobMigrated)
				if err := _CanWorkJob.contract.UnpackLog(event, "Migrated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCancelEscrowIterator is returned from FilterOnCancelEscrow and is used to iterate over the raw logs and unpacked data for OnCancelEscrow events raised by the CanWorkJob contract.
type CanWorkJobOnCancelEscrowIterator struct {
	Event *CanWorkJobOnCancelEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCancelEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCancelEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCancelEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCancelEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCancelEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCancelEscrow represents a OnCancelEscrow event raised by the CanWorkJob contract.
type CanWorkJobOnCancelEscrow struct {
	Dapp                common.Address
	EscrowId            *big.Int
	PayToProviderAmount *big.Int
	Arbiter             common.Address
	PayToArbiterAmount  *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrow is a free log retrieval operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCancelEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (*CanWorkJobOnCancelEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCancelEscrowIterator{contract: _CanWorkJob.contract, event: "OnCancelEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrow is a free log subscription operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCancelEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCancelEscrow, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCancelEscrow)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCancelEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCancelEscrowByProviderIterator is returned from FilterOnCancelEscrowByProvider and is used to iterate over the raw logs and unpacked data for OnCancelEscrowByProvider events raised by the CanWorkJob contract.
type CanWorkJobOnCancelEscrowByProviderIterator struct {
	Event *CanWorkJobOnCancelEscrowByProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCancelEscrowByProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCancelEscrowByProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCancelEscrowByProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCancelEscrowByProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCancelEscrowByProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCancelEscrowByProvider represents a OnCancelEscrowByProvider event raised by the CanWorkJob contract.
type CanWorkJobOnCancelEscrowByProvider struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrowByProvider is a free log retrieval operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCancelEscrowByProvider(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*CanWorkJobOnCancelEscrowByProviderIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCancelEscrowByProviderIterator{contract: _CanWorkJob.contract, event: "OnCancelEscrowByProvider", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrowByProvider is a free log subscription operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCancelEscrowByProvider(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCancelEscrowByProvider, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCancelEscrowByProvider)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCancelEscrowByProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCancelJobByAdminIterator is returned from FilterOnCancelJobByAdmin and is used to iterate over the raw logs and unpacked data for OnCancelJobByAdmin events raised by the CanWorkJob contract.
type CanWorkJobOnCancelJobByAdminIterator struct {
	Event *CanWorkJobOnCancelJobByAdmin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCancelJobByAdminIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCancelJobByAdmin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCancelJobByAdmin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCancelJobByAdminIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCancelJobByAdminIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCancelJobByAdmin represents a OnCancelJobByAdmin event raised by the CanWorkJob contract.
type CanWorkJobOnCancelJobByAdmin struct {
	Dapp                    common.Address
	JobId                   [32]byte
	PayToProviderPercentage uint8
	Arbiter                 common.Address
	PayToArbiterPercentage  uint8
	Raw                     types.Log // Blockchain specific contextual infos
}

// FilterOnCancelJobByAdmin is a free log retrieval operation binding the contract event 0xb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611.
//
// Solidity: e OnCancelJobByAdmin(dapp indexed address, jobId indexed bytes32, payToProviderPercentage uint8, arbiter indexed address, payToArbiterPercentage uint8)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCancelJobByAdmin(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte, arbiter []common.Address) (*CanWorkJobOnCancelJobByAdminIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCancelJobByAdmin", dappRule, jobIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCancelJobByAdminIterator{contract: _CanWorkJob.contract, event: "OnCancelJobByAdmin", logs: logs, sub: sub}, nil
}

// WatchOnCancelJobByAdmin is a free log subscription operation binding the contract event 0xb5147162f3f7e77567ea20823c3339ae369a07c96dafce09964879ed9ea17611.
//
// Solidity: e OnCancelJobByAdmin(dapp indexed address, jobId indexed bytes32, payToProviderPercentage uint8, arbiter indexed address, payToArbiterPercentage uint8)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCancelJobByAdmin(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCancelJobByAdmin, dapp []common.Address, jobId [][32]byte, arbiter []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCancelJobByAdmin", dappRule, jobIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCancelJobByAdmin)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCancelJobByAdmin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCancelJobByProviderIterator is returned from FilterOnCancelJobByProvider and is used to iterate over the raw logs and unpacked data for OnCancelJobByProvider events raised by the CanWorkJob contract.
type CanWorkJobOnCancelJobByProviderIterator struct {
	Event *CanWorkJobOnCancelJobByProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCancelJobByProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCancelJobByProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCancelJobByProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCancelJobByProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCancelJobByProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCancelJobByProvider represents a OnCancelJobByProvider event raised by the CanWorkJob contract.
type CanWorkJobOnCancelJobByProvider struct {
	Dapp  common.Address
	JobId [32]byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterOnCancelJobByProvider is a free log retrieval operation binding the contract event 0x9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c426.
//
// Solidity: e OnCancelJobByProvider(dapp indexed address, jobId indexed bytes32)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCancelJobByProvider(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte) (*CanWorkJobOnCancelJobByProviderIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCancelJobByProvider", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCancelJobByProviderIterator{contract: _CanWorkJob.contract, event: "OnCancelJobByProvider", logs: logs, sub: sub}, nil
}

// WatchOnCancelJobByProvider is a free log subscription operation binding the contract event 0x9deeb35dcae810f88ff11beec766eaa1b2e9f1ef7bcefbb8f2a3f91fdf98c426.
//
// Solidity: e OnCancelJobByProvider(dapp indexed address, jobId indexed bytes32)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCancelJobByProvider(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCancelJobByProvider, dapp []common.Address, jobId [][32]byte) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCancelJobByProvider", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCancelJobByProvider)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCancelJobByProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCompleteEscrowIterator is returned from FilterOnCompleteEscrow and is used to iterate over the raw logs and unpacked data for OnCompleteEscrow events raised by the CanWorkJob contract.
type CanWorkJobOnCompleteEscrowIterator struct {
	Event *CanWorkJobOnCompleteEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCompleteEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCompleteEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCompleteEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCompleteEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCompleteEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCompleteEscrow represents a OnCompleteEscrow event raised by the CanWorkJob contract.
type CanWorkJobOnCompleteEscrow struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCompleteEscrow is a free log retrieval operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCompleteEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*CanWorkJobOnCompleteEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCompleteEscrowIterator{contract: _CanWorkJob.contract, event: "OnCompleteEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCompleteEscrow is a free log subscription operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCompleteEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCompleteEscrow, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCompleteEscrow)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCompleteEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCompleteJobIterator is returned from FilterOnCompleteJob and is used to iterate over the raw logs and unpacked data for OnCompleteJob events raised by the CanWorkJob contract.
type CanWorkJobOnCompleteJobIterator struct {
	Event *CanWorkJobOnCompleteJob // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCompleteJobIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCompleteJob)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCompleteJob)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCompleteJobIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCompleteJobIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCompleteJob represents a OnCompleteJob event raised by the CanWorkJob contract.
type CanWorkJobOnCompleteJob struct {
	Dapp  common.Address
	JobId [32]byte
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterOnCompleteJob is a free log retrieval operation binding the contract event 0x5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a.
//
// Solidity: e OnCompleteJob(dapp indexed address, jobId indexed bytes32)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCompleteJob(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte) (*CanWorkJobOnCompleteJobIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCompleteJob", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCompleteJobIterator{contract: _CanWorkJob.contract, event: "OnCompleteJob", logs: logs, sub: sub}, nil
}

// WatchOnCompleteJob is a free log subscription operation binding the contract event 0x5fa8e6f4fbdedc8f67f68ed5dd5a194353476578eb9231d8925543e55fec008a.
//
// Solidity: e OnCompleteJob(dapp indexed address, jobId indexed bytes32)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCompleteJob(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCompleteJob, dapp []common.Address, jobId [][32]byte) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCompleteJob", dappRule, jobIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCompleteJob)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCompleteJob", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCreateEscrowIterator is returned from FilterOnCreateEscrow and is used to iterate over the raw logs and unpacked data for OnCreateEscrow events raised by the CanWorkJob contract.
type CanWorkJobOnCreateEscrowIterator struct {
	Event *CanWorkJobOnCreateEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCreateEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCreateEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCreateEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCreateEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCreateEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCreateEscrow represents a OnCreateEscrow event raised by the CanWorkJob contract.
type CanWorkJobOnCreateEscrow struct {
	Dapp      common.Address
	Client    common.Address
	Provider  common.Address
	Amount    *big.Int
	DaiAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterOnCreateEscrow is a free log retrieval operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCreateEscrow(opts *bind.FilterOpts, dapp []common.Address, client []common.Address, provider []common.Address) (*CanWorkJobOnCreateEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCreateEscrowIterator{contract: _CanWorkJob.contract, event: "OnCreateEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCreateEscrow is a free log subscription operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCreateEscrow(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCreateEscrow, dapp []common.Address, client []common.Address, provider []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCreateEscrow)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCreateEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnCreateJobIterator is returned from FilterOnCreateJob and is used to iterate over the raw logs and unpacked data for OnCreateJob events raised by the CanWorkJob contract.
type CanWorkJobOnCreateJobIterator struct {
	Event *CanWorkJobOnCreateJob // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnCreateJobIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnCreateJob)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnCreateJob)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnCreateJobIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnCreateJobIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnCreateJob represents a OnCreateJob event raised by the CanWorkJob contract.
type CanWorkJobOnCreateJob struct {
	Dapp       common.Address
	JobId      [32]byte
	Client     common.Address
	Provider   common.Address
	TotalCosts *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterOnCreateJob is a free log retrieval operation binding the contract event 0x06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e.
//
// Solidity: e OnCreateJob(dapp indexed address, jobId indexed bytes32, client address, provider indexed address, totalCosts uint256)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnCreateJob(opts *bind.FilterOpts, dapp []common.Address, jobId [][32]byte, provider []common.Address) (*CanWorkJobOnCreateJobIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnCreateJob", dappRule, jobIdRule, providerRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnCreateJobIterator{contract: _CanWorkJob.contract, event: "OnCreateJob", logs: logs, sub: sub}, nil
}

// WatchOnCreateJob is a free log subscription operation binding the contract event 0x06ec2805bab16df077e1bf66c474762caec30f56f6c01e4e673aa60b8dca979e.
//
// Solidity: e OnCreateJob(dapp indexed address, jobId indexed bytes32, client address, provider indexed address, totalCosts uint256)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnCreateJob(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnCreateJob, dapp []common.Address, jobId [][32]byte, provider []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var jobIdRule []interface{}
	for _, jobIdItem := range jobId {
		jobIdRule = append(jobIdRule, jobIdItem)
	}

	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnCreateJob", dappRule, jobIdRule, providerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnCreateJob)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnCreateJob", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// CanWorkJobOnInitializeIterator is returned from FilterOnInitialize and is used to iterate over the raw logs and unpacked data for OnInitialize events raised by the CanWorkJob contract.
type CanWorkJobOnInitializeIterator struct {
	Event *CanWorkJobOnInitialize // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CanWorkJobOnInitializeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CanWorkJobOnInitialize)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CanWorkJobOnInitialize)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CanWorkJobOnInitializeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CanWorkJobOnInitializeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CanWorkJobOnInitialize represents a OnInitialize event raised by the CanWorkJob contract.
type CanWorkJobOnInitialize struct {
	Token       common.Address
	DApp        common.Address
	PriceOracle common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterOnInitialize is a free log retrieval operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_CanWorkJob *CanWorkJobFilterer) FilterOnInitialize(opts *bind.FilterOpts, token []common.Address, dApp []common.Address) (*CanWorkJobOnInitializeIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _CanWorkJob.contract.FilterLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return &CanWorkJobOnInitializeIterator{contract: _CanWorkJob.contract, event: "OnInitialize", logs: logs, sub: sub}, nil
}

// WatchOnInitialize is a free log subscription operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_CanWorkJob *CanWorkJobFilterer) WatchOnInitialize(opts *bind.WatchOpts, sink chan<- *CanWorkJobOnInitialize, token []common.Address, dApp []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _CanWorkJob.contract.WatchLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CanWorkJobOnInitialize)
				if err := _CanWorkJob.contract.UnpackLog(event, "OnInitialize", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ERC20ABI is the input ABI used to generate the binding from.
const ERC20ABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ERC20Bin is the compiled bytecode used for deploying new contracts.
const ERC20Bin = `0x`

// DeployERC20 deploys a new Ethereum contract, binding an instance of ERC20 to it.
func DeployERC20(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC20Bin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// ERC20 is an auto generated Go binding around an Ethereum contract.
type ERC20 struct {
	ERC20Caller     // Read-only binding to the contract
	ERC20Transactor // Write-only binding to the contract
	ERC20Filterer   // Log filterer for contract events
}

// ERC20Caller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20Caller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Transactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20Transactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Filterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20Filterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20Session is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20Session struct {
	Contract     *ERC20            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20CallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20CallerSession struct {
	Contract *ERC20Caller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ERC20TransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20TransactorSession struct {
	Contract     *ERC20Transactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20Raw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20Raw struct {
	Contract *ERC20 // Generic contract binding to access the raw methods on
}

// ERC20CallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20CallerRaw struct {
	Contract *ERC20Caller // Generic read-only contract binding to access the raw methods on
}

// ERC20TransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20TransactorRaw struct {
	Contract *ERC20Transactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20 creates a new instance of ERC20, bound to a specific deployed contract.
func NewERC20(address common.Address, backend bind.ContractBackend) (*ERC20, error) {
	contract, err := bindERC20(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20{ERC20Caller: ERC20Caller{contract: contract}, ERC20Transactor: ERC20Transactor{contract: contract}, ERC20Filterer: ERC20Filterer{contract: contract}}, nil
}

// NewERC20Caller creates a new read-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Caller(address common.Address, caller bind.ContractCaller) (*ERC20Caller, error) {
	contract, err := bindERC20(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Caller{contract: contract}, nil
}

// NewERC20Transactor creates a new write-only instance of ERC20, bound to a specific deployed contract.
func NewERC20Transactor(address common.Address, transactor bind.ContractTransactor) (*ERC20Transactor, error) {
	contract, err := bindERC20(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20Transactor{contract: contract}, nil
}

// NewERC20Filterer creates a new log filterer instance of ERC20, bound to a specific deployed contract.
func NewERC20Filterer(address common.Address, filterer bind.ContractFilterer) (*ERC20Filterer, error) {
	contract, err := bindERC20(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20Filterer{contract: contract}, nil
}

// bindERC20 binds a generic wrapper to an already deployed contract.
func bindERC20(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20ABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20Raw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.ERC20Caller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20Raw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20Raw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.ERC20Transactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20 *ERC20CallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20 *ERC20TransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20 *ERC20TransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20.Contract.contract.Transact(opts, method, params...)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(owner address, spender address) constant returns(uint256)
func (_ERC20 *ERC20Caller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "allowance", owner, spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(owner address, spender address) constant returns(uint256)
func (_ERC20 *ERC20Session) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(owner address, spender address) constant returns(uint256)
func (_ERC20 *ERC20CallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _ERC20.Contract.Allowance(&_ERC20.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(who address) constant returns(uint256)
func (_ERC20 *ERC20Caller) BalanceOf(opts *bind.CallOpts, who common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "balanceOf", who)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(who address) constant returns(uint256)
func (_ERC20 *ERC20Session) BalanceOf(who common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, who)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(who address) constant returns(uint256)
func (_ERC20 *ERC20CallerSession) BalanceOf(who common.Address) (*big.Int, error) {
	return _ERC20.Contract.BalanceOf(&_ERC20.CallOpts, who)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC20 *ERC20Caller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC20 *ERC20Session) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256)
func (_ERC20 *ERC20CallerSession) TotalSupply() (*big.Int, error) {
	return _ERC20.Contract.TotalSupply(&_ERC20.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(spender address, value uint256) returns(bool)
func (_ERC20 *ERC20Transactor) Approve(opts *bind.TransactOpts, spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "approve", spender, value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(spender address, value uint256) returns(bool)
func (_ERC20 *ERC20Session) Approve(spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(spender address, value uint256) returns(bool)
func (_ERC20 *ERC20TransactorSession) Approve(spender common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Approve(&_ERC20.TransactOpts, spender, value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(to address, value uint256) returns(bool)
func (_ERC20 *ERC20Transactor) Transfer(opts *bind.TransactOpts, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transfer", to, value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(to address, value uint256) returns(bool)
func (_ERC20 *ERC20Session) Transfer(to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(to address, value uint256) returns(bool)
func (_ERC20 *ERC20TransactorSession) Transfer(to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.Transfer(&_ERC20.TransactOpts, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(from address, to address, value uint256) returns(bool)
func (_ERC20 *ERC20Transactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.contract.Transact(opts, "transferFrom", from, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(from address, to address, value uint256) returns(bool)
func (_ERC20 *ERC20Session) TransferFrom(from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(from address, to address, value uint256) returns(bool)
func (_ERC20 *ERC20TransactorSession) TransferFrom(from common.Address, to common.Address, value *big.Int) (*types.Transaction, error) {
	return _ERC20.Contract.TransferFrom(&_ERC20.TransactOpts, from, to, value)
}

// ERC20BancorPriceOracleABI is the input ABI used to generate the binding from.
const ERC20BancorPriceOracleABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getTokenToDai\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_daiAmount\",\"type\":\"uint256\"}],\"name\":\"getDaiToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ERC20BancorPriceOracleBin is the compiled bytecode used for deploying new contracts.
const ERC20BancorPriceOracleBin = `0x`

// DeployERC20BancorPriceOracle deploys a new Ethereum contract, binding an instance of ERC20BancorPriceOracle to it.
func DeployERC20BancorPriceOracle(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20BancorPriceOracle, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20BancorPriceOracleABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ERC20BancorPriceOracleBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20BancorPriceOracle{ERC20BancorPriceOracleCaller: ERC20BancorPriceOracleCaller{contract: contract}, ERC20BancorPriceOracleTransactor: ERC20BancorPriceOracleTransactor{contract: contract}, ERC20BancorPriceOracleFilterer: ERC20BancorPriceOracleFilterer{contract: contract}}, nil
}

// ERC20BancorPriceOracle is an auto generated Go binding around an Ethereum contract.
type ERC20BancorPriceOracle struct {
	ERC20BancorPriceOracleCaller     // Read-only binding to the contract
	ERC20BancorPriceOracleTransactor // Write-only binding to the contract
	ERC20BancorPriceOracleFilterer   // Log filterer for contract events
}

// ERC20BancorPriceOracleCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20BancorPriceOracleCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BancorPriceOracleTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20BancorPriceOracleTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BancorPriceOracleFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20BancorPriceOracleFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BancorPriceOracleSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20BancorPriceOracleSession struct {
	Contract     *ERC20BancorPriceOracle // Generic contract binding to set the session for
	CallOpts     bind.CallOpts           // Call options to use throughout this session
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// ERC20BancorPriceOracleCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20BancorPriceOracleCallerSession struct {
	Contract *ERC20BancorPriceOracleCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                 // Call options to use throughout this session
}

// ERC20BancorPriceOracleTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20BancorPriceOracleTransactorSession struct {
	Contract     *ERC20BancorPriceOracleTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                 // Transaction auth options to use throughout this session
}

// ERC20BancorPriceOracleRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20BancorPriceOracleRaw struct {
	Contract *ERC20BancorPriceOracle // Generic contract binding to access the raw methods on
}

// ERC20BancorPriceOracleCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20BancorPriceOracleCallerRaw struct {
	Contract *ERC20BancorPriceOracleCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20BancorPriceOracleTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20BancorPriceOracleTransactorRaw struct {
	Contract *ERC20BancorPriceOracleTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20BancorPriceOracle creates a new instance of ERC20BancorPriceOracle, bound to a specific deployed contract.
func NewERC20BancorPriceOracle(address common.Address, backend bind.ContractBackend) (*ERC20BancorPriceOracle, error) {
	contract, err := bindERC20BancorPriceOracle(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20BancorPriceOracle{ERC20BancorPriceOracleCaller: ERC20BancorPriceOracleCaller{contract: contract}, ERC20BancorPriceOracleTransactor: ERC20BancorPriceOracleTransactor{contract: contract}, ERC20BancorPriceOracleFilterer: ERC20BancorPriceOracleFilterer{contract: contract}}, nil
}

// NewERC20BancorPriceOracleCaller creates a new read-only instance of ERC20BancorPriceOracle, bound to a specific deployed contract.
func NewERC20BancorPriceOracleCaller(address common.Address, caller bind.ContractCaller) (*ERC20BancorPriceOracleCaller, error) {
	contract, err := bindERC20BancorPriceOracle(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BancorPriceOracleCaller{contract: contract}, nil
}

// NewERC20BancorPriceOracleTransactor creates a new write-only instance of ERC20BancorPriceOracle, bound to a specific deployed contract.
func NewERC20BancorPriceOracleTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20BancorPriceOracleTransactor, error) {
	contract, err := bindERC20BancorPriceOracle(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BancorPriceOracleTransactor{contract: contract}, nil
}

// NewERC20BancorPriceOracleFilterer creates a new log filterer instance of ERC20BancorPriceOracle, bound to a specific deployed contract.
func NewERC20BancorPriceOracleFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20BancorPriceOracleFilterer, error) {
	contract, err := bindERC20BancorPriceOracle(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20BancorPriceOracleFilterer{contract: contract}, nil
}

// bindERC20BancorPriceOracle binds a generic wrapper to an already deployed contract.
func bindERC20BancorPriceOracle(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ERC20BancorPriceOracleABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20BancorPriceOracle.Contract.ERC20BancorPriceOracleCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20BancorPriceOracle.Contract.ERC20BancorPriceOracleTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20BancorPriceOracle.Contract.ERC20BancorPriceOracleTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ERC20BancorPriceOracle.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20BancorPriceOracle.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20BancorPriceOracle.Contract.contract.Transact(opts, method, params...)
}

// GetDaiToToken is a free data retrieval call binding the contract method 0xc8a1d96e.
//
// Solidity: function getDaiToToken(_daiAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleCaller) GetDaiToToken(opts *bind.CallOpts, _daiAmount *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20BancorPriceOracle.contract.Call(opts, out, "getDaiToToken", _daiAmount)
	return *ret0, err
}

// GetDaiToToken is a free data retrieval call binding the contract method 0xc8a1d96e.
//
// Solidity: function getDaiToToken(_daiAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleSession) GetDaiToToken(_daiAmount *big.Int) (*big.Int, error) {
	return _ERC20BancorPriceOracle.Contract.GetDaiToToken(&_ERC20BancorPriceOracle.CallOpts, _daiAmount)
}

// GetDaiToToken is a free data retrieval call binding the contract method 0xc8a1d96e.
//
// Solidity: function getDaiToToken(_daiAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleCallerSession) GetDaiToToken(_daiAmount *big.Int) (*big.Int, error) {
	return _ERC20BancorPriceOracle.Contract.GetDaiToToken(&_ERC20BancorPriceOracle.CallOpts, _daiAmount)
}

// GetTokenToDai is a free data retrieval call binding the contract method 0x9fd650ce.
//
// Solidity: function getTokenToDai(_tokenAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleCaller) GetTokenToDai(opts *bind.CallOpts, _tokenAmount *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ERC20BancorPriceOracle.contract.Call(opts, out, "getTokenToDai", _tokenAmount)
	return *ret0, err
}

// GetTokenToDai is a free data retrieval call binding the contract method 0x9fd650ce.
//
// Solidity: function getTokenToDai(_tokenAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleSession) GetTokenToDai(_tokenAmount *big.Int) (*big.Int, error) {
	return _ERC20BancorPriceOracle.Contract.GetTokenToDai(&_ERC20BancorPriceOracle.CallOpts, _tokenAmount)
}

// GetTokenToDai is a free data retrieval call binding the contract method 0x9fd650ce.
//
// Solidity: function getTokenToDai(_tokenAmount uint256) constant returns(uint256)
func (_ERC20BancorPriceOracle *ERC20BancorPriceOracleCallerSession) GetTokenToDai(_tokenAmount *big.Int) (*big.Int, error) {
	return _ERC20BancorPriceOracle.Contract.GetTokenToDai(&_ERC20BancorPriceOracle.CallOpts, _tokenAmount)
}

// EscrowABI is the input ABI used to generate the binding from.
const EscrowABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrow\",\"outputs\":[{\"name\":\"client\",\"type\":\"address\"},{\"name\":\"provider\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"closedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"isMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_escrowId\",\"type\":\"uint256\"}],\"name\":\"getEscrowPayments\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"totalValueDai\",\"type\":\"uint256\"},{\"name\":\"payoutAmount\",\"type\":\"uint256\"},{\"name\":\"paidToDappAmount\",\"type\":\"uint256\"},{\"name\":\"paidToProviderAmount\",\"type\":\"uint256\"},{\"name\":\"paidToClientAmount\",\"type\":\"uint256\"},{\"name\":\"paidToArbiterAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dApp\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceOracle\",\"type\":\"address\"}],\"name\":\"OnInitialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"client\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"daiAmount\",\"type\":\"uint256\"}],\"name\":\"OnCreateEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCompleteEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrowByProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"dapp\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"escrowId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payToProviderAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"arbiter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"payToArbiterAmount\",\"type\":\"uint256\"}],\"name\":\"OnCancelEscrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"Migrated\",\"type\":\"event\"}]"

// EscrowBin is the compiled bytecode used for deploying new contracts.
const EscrowBin = `0x6080604052600060025534801561001557600080fd5b50610516806100256000396000f3006080604052600436106100615763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416632630c12f81146100665780637d19e596146100a4578063c0bac1a814610110578063fd232b59146101bb575b600080fd5b34801561007257600080fd5b5061007b61020b565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b3480156100b057600080fd5b506100bc600435610227565b6040805173ffffffffffffffffffffffffffffffffffffffff988916815296909716602087015285870194909452606085019290925260ff16608084015260a083015260c082015290519081900360e00190f35b34801561011c57600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526101a794369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506103469650505050505050565b604080519115158252519081900360200190f35b3480156101c757600080fd5b506101d360043561040d565b604080519788526020880196909652868601949094526060860192909252608085015260a084015260c0830152519081900360e00190f35b60055473ffffffffffffffffffffffffffffffffffffffff1681565b600080600080600080600080881180156102505750600088815260066020819052604082200154115b15156102bd57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b600088815260066020526040902060018101546002808301546003840154600485015460059095015473ffffffffffffffffffffffffffffffffffffffff948516959290941693909260ff9091169081111561031557fe5b60009c8d52600660208190526040909d209c8d01546007909d0154949d939c929b5090995097509550909350915050565b600080836040518082805190602001908083835b602083106103795780518252601f19909201916020918201910161035a565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b602083106103d55780518252601f1990920191602091820191016103b6565b51815160209384036101000a600019018019909216911617905292019485525060405193849003019092205460ff1695945050505050565b600080600080600080600080881180156104365750600088815260066020819052604082200154115b15156104a357604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f4d75737420626520612076616c696420657363726f7720496400000000000000604482015290519081900360640190fd5b5050506000948552505060066020525050604090206003810154600482015460088301546009840154600a850154600b860154600c909601549496939592949193909291905600a165627a7a72305820c8e2f10d036a56689634946a9ed46b1d03fee2d89eecc30d8ac4e7f8642597110029`

// DeployEscrow deploys a new Ethereum contract, binding an instance of Escrow to it.
func DeployEscrow(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Escrow, error) {
	parsed, err := abi.JSON(strings.NewReader(EscrowABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(EscrowBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Escrow{EscrowCaller: EscrowCaller{contract: contract}, EscrowTransactor: EscrowTransactor{contract: contract}, EscrowFilterer: EscrowFilterer{contract: contract}}, nil
}

// Escrow is an auto generated Go binding around an Ethereum contract.
type Escrow struct {
	EscrowCaller     // Read-only binding to the contract
	EscrowTransactor // Write-only binding to the contract
	EscrowFilterer   // Log filterer for contract events
}

// EscrowCaller is an auto generated read-only Go binding around an Ethereum contract.
type EscrowCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EscrowTransactor is an auto generated write-only Go binding around an Ethereum contract.
type EscrowTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EscrowFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type EscrowFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// EscrowSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type EscrowSession struct {
	Contract     *Escrow           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EscrowCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type EscrowCallerSession struct {
	Contract *EscrowCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// EscrowTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type EscrowTransactorSession struct {
	Contract     *EscrowTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// EscrowRaw is an auto generated low-level Go binding around an Ethereum contract.
type EscrowRaw struct {
	Contract *Escrow // Generic contract binding to access the raw methods on
}

// EscrowCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type EscrowCallerRaw struct {
	Contract *EscrowCaller // Generic read-only contract binding to access the raw methods on
}

// EscrowTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type EscrowTransactorRaw struct {
	Contract *EscrowTransactor // Generic write-only contract binding to access the raw methods on
}

// NewEscrow creates a new instance of Escrow, bound to a specific deployed contract.
func NewEscrow(address common.Address, backend bind.ContractBackend) (*Escrow, error) {
	contract, err := bindEscrow(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Escrow{EscrowCaller: EscrowCaller{contract: contract}, EscrowTransactor: EscrowTransactor{contract: contract}, EscrowFilterer: EscrowFilterer{contract: contract}}, nil
}

// NewEscrowCaller creates a new read-only instance of Escrow, bound to a specific deployed contract.
func NewEscrowCaller(address common.Address, caller bind.ContractCaller) (*EscrowCaller, error) {
	contract, err := bindEscrow(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &EscrowCaller{contract: contract}, nil
}

// NewEscrowTransactor creates a new write-only instance of Escrow, bound to a specific deployed contract.
func NewEscrowTransactor(address common.Address, transactor bind.ContractTransactor) (*EscrowTransactor, error) {
	contract, err := bindEscrow(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &EscrowTransactor{contract: contract}, nil
}

// NewEscrowFilterer creates a new log filterer instance of Escrow, bound to a specific deployed contract.
func NewEscrowFilterer(address common.Address, filterer bind.ContractFilterer) (*EscrowFilterer, error) {
	contract, err := bindEscrow(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &EscrowFilterer{contract: contract}, nil
}

// bindEscrow binds a generic wrapper to an already deployed contract.
func bindEscrow(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(EscrowABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Escrow *EscrowRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Escrow.Contract.EscrowCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Escrow *EscrowRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Escrow.Contract.EscrowTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Escrow *EscrowRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Escrow.Contract.EscrowTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Escrow *EscrowCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Escrow.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Escrow *EscrowTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Escrow.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Escrow *EscrowTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Escrow.Contract.contract.Transact(opts, method, params...)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_Escrow *EscrowCaller) GetEscrow(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	ret := new(struct {
		Client        common.Address
		Provider      common.Address
		Amount        *big.Int
		TotalValueDai *big.Int
		Status        uint8
		CreatedAt     *big.Int
		ClosedAt      *big.Int
	})
	out := ret
	err := _Escrow.contract.Call(opts, out, "getEscrow", _escrowId)
	return *ret, err
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_Escrow *EscrowSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _Escrow.Contract.GetEscrow(&_Escrow.CallOpts, _escrowId)
}

// GetEscrow is a free data retrieval call binding the contract method 0x7d19e596.
//
// Solidity: function getEscrow(_escrowId uint256) constant returns(client address, provider address, amount uint256, totalValueDai uint256, status uint8, createdAt uint256, closedAt uint256)
func (_Escrow *EscrowCallerSession) GetEscrow(_escrowId *big.Int) (struct {
	Client        common.Address
	Provider      common.Address
	Amount        *big.Int
	TotalValueDai *big.Int
	Status        uint8
	CreatedAt     *big.Int
	ClosedAt      *big.Int
}, error) {
	return _Escrow.Contract.GetEscrow(&_Escrow.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_Escrow *EscrowCaller) GetEscrowPayments(opts *bind.CallOpts, _escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	ret := new(struct {
		Amount               *big.Int
		TotalValueDai        *big.Int
		PayoutAmount         *big.Int
		PaidToDappAmount     *big.Int
		PaidToProviderAmount *big.Int
		PaidToClientAmount   *big.Int
		PaidToArbiterAmount  *big.Int
	})
	out := ret
	err := _Escrow.contract.Call(opts, out, "getEscrowPayments", _escrowId)
	return *ret, err
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_Escrow *EscrowSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _Escrow.Contract.GetEscrowPayments(&_Escrow.CallOpts, _escrowId)
}

// GetEscrowPayments is a free data retrieval call binding the contract method 0xfd232b59.
//
// Solidity: function getEscrowPayments(_escrowId uint256) constant returns(amount uint256, totalValueDai uint256, payoutAmount uint256, paidToDappAmount uint256, paidToProviderAmount uint256, paidToClientAmount uint256, paidToArbiterAmount uint256)
func (_Escrow *EscrowCallerSession) GetEscrowPayments(_escrowId *big.Int) (struct {
	Amount               *big.Int
	TotalValueDai        *big.Int
	PayoutAmount         *big.Int
	PaidToDappAmount     *big.Int
	PaidToProviderAmount *big.Int
	PaidToClientAmount   *big.Int
	PaidToArbiterAmount  *big.Int
}, error) {
	return _Escrow.Contract.GetEscrowPayments(&_Escrow.CallOpts, _escrowId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Escrow *EscrowCaller) IsMigrated(opts *bind.CallOpts, contractName string, migrationId string) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Escrow.contract.Call(opts, out, "isMigrated", contractName, migrationId)
	return *ret0, err
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Escrow *EscrowSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _Escrow.Contract.IsMigrated(&_Escrow.CallOpts, contractName, migrationId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Escrow *EscrowCallerSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _Escrow.Contract.IsMigrated(&_Escrow.CallOpts, contractName, migrationId)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_Escrow *EscrowCaller) PriceOracle(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Escrow.contract.Call(opts, out, "priceOracle")
	return *ret0, err
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_Escrow *EscrowSession) PriceOracle() (common.Address, error) {
	return _Escrow.Contract.PriceOracle(&_Escrow.CallOpts)
}

// PriceOracle is a free data retrieval call binding the contract method 0x2630c12f.
//
// Solidity: function priceOracle() constant returns(address)
func (_Escrow *EscrowCallerSession) PriceOracle() (common.Address, error) {
	return _Escrow.Contract.PriceOracle(&_Escrow.CallOpts)
}

// EscrowMigratedIterator is returned from FilterMigrated and is used to iterate over the raw logs and unpacked data for Migrated events raised by the Escrow contract.
type EscrowMigratedIterator struct {
	Event *EscrowMigrated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowMigratedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowMigrated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowMigrated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowMigratedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowMigratedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowMigrated represents a Migrated event raised by the Escrow contract.
type EscrowMigrated struct {
	ContractName string
	MigrationId  string
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterMigrated is a free log retrieval operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_Escrow *EscrowFilterer) FilterMigrated(opts *bind.FilterOpts) (*EscrowMigratedIterator, error) {

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return &EscrowMigratedIterator{contract: _Escrow.contract, event: "Migrated", logs: logs, sub: sub}, nil
}

// WatchMigrated is a free log subscription operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_Escrow *EscrowFilterer) WatchMigrated(opts *bind.WatchOpts, sink chan<- *EscrowMigrated) (event.Subscription, error) {

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowMigrated)
				if err := _Escrow.contract.UnpackLog(event, "Migrated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// EscrowOnCancelEscrowIterator is returned from FilterOnCancelEscrow and is used to iterate over the raw logs and unpacked data for OnCancelEscrow events raised by the Escrow contract.
type EscrowOnCancelEscrowIterator struct {
	Event *EscrowOnCancelEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowOnCancelEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowOnCancelEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowOnCancelEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowOnCancelEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowOnCancelEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowOnCancelEscrow represents a OnCancelEscrow event raised by the Escrow contract.
type EscrowOnCancelEscrow struct {
	Dapp                common.Address
	EscrowId            *big.Int
	PayToProviderAmount *big.Int
	Arbiter             common.Address
	PayToArbiterAmount  *big.Int
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrow is a free log retrieval operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_Escrow *EscrowFilterer) FilterOnCancelEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (*EscrowOnCancelEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return &EscrowOnCancelEscrowIterator{contract: _Escrow.contract, event: "OnCancelEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrow is a free log subscription operation binding the contract event 0x23157ee5a4e89bcebb1fc3e9b6e1533aefe88f9bde92308b49a71e800103542b.
//
// Solidity: e OnCancelEscrow(dapp indexed address, escrowId indexed uint256, payToProviderAmount uint256, arbiter indexed address, payToArbiterAmount uint256)
func (_Escrow *EscrowFilterer) WatchOnCancelEscrow(opts *bind.WatchOpts, sink chan<- *EscrowOnCancelEscrow, dapp []common.Address, escrowId []*big.Int, arbiter []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	var arbiterRule []interface{}
	for _, arbiterItem := range arbiter {
		arbiterRule = append(arbiterRule, arbiterItem)
	}

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "OnCancelEscrow", dappRule, escrowIdRule, arbiterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowOnCancelEscrow)
				if err := _Escrow.contract.UnpackLog(event, "OnCancelEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// EscrowOnCancelEscrowByProviderIterator is returned from FilterOnCancelEscrowByProvider and is used to iterate over the raw logs and unpacked data for OnCancelEscrowByProvider events raised by the Escrow contract.
type EscrowOnCancelEscrowByProviderIterator struct {
	Event *EscrowOnCancelEscrowByProvider // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowOnCancelEscrowByProviderIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowOnCancelEscrowByProvider)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowOnCancelEscrowByProvider)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowOnCancelEscrowByProviderIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowOnCancelEscrowByProviderIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowOnCancelEscrowByProvider represents a OnCancelEscrowByProvider event raised by the Escrow contract.
type EscrowOnCancelEscrowByProvider struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCancelEscrowByProvider is a free log retrieval operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_Escrow *EscrowFilterer) FilterOnCancelEscrowByProvider(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*EscrowOnCancelEscrowByProviderIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &EscrowOnCancelEscrowByProviderIterator{contract: _Escrow.contract, event: "OnCancelEscrowByProvider", logs: logs, sub: sub}, nil
}

// WatchOnCancelEscrowByProvider is a free log subscription operation binding the contract event 0x42a9d051cfad92ff80e72d1f2fe48fd37941d2e3d8a231b4a2a6993474dd6726.
//
// Solidity: e OnCancelEscrowByProvider(dapp indexed address, escrowId indexed uint256)
func (_Escrow *EscrowFilterer) WatchOnCancelEscrowByProvider(opts *bind.WatchOpts, sink chan<- *EscrowOnCancelEscrowByProvider, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "OnCancelEscrowByProvider", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowOnCancelEscrowByProvider)
				if err := _Escrow.contract.UnpackLog(event, "OnCancelEscrowByProvider", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// EscrowOnCompleteEscrowIterator is returned from FilterOnCompleteEscrow and is used to iterate over the raw logs and unpacked data for OnCompleteEscrow events raised by the Escrow contract.
type EscrowOnCompleteEscrowIterator struct {
	Event *EscrowOnCompleteEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowOnCompleteEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowOnCompleteEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowOnCompleteEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowOnCompleteEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowOnCompleteEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowOnCompleteEscrow represents a OnCompleteEscrow event raised by the Escrow contract.
type EscrowOnCompleteEscrow struct {
	Dapp     common.Address
	EscrowId *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterOnCompleteEscrow is a free log retrieval operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_Escrow *EscrowFilterer) FilterOnCompleteEscrow(opts *bind.FilterOpts, dapp []common.Address, escrowId []*big.Int) (*EscrowOnCompleteEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return &EscrowOnCompleteEscrowIterator{contract: _Escrow.contract, event: "OnCompleteEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCompleteEscrow is a free log subscription operation binding the contract event 0x4bebfffc0dc0fb54ffd42c8fe2424e8fe0c482f089c4d0d6e6f1ea5d9e34248a.
//
// Solidity: e OnCompleteEscrow(dapp indexed address, escrowId indexed uint256)
func (_Escrow *EscrowFilterer) WatchOnCompleteEscrow(opts *bind.WatchOpts, sink chan<- *EscrowOnCompleteEscrow, dapp []common.Address, escrowId []*big.Int) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var escrowIdRule []interface{}
	for _, escrowIdItem := range escrowId {
		escrowIdRule = append(escrowIdRule, escrowIdItem)
	}

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "OnCompleteEscrow", dappRule, escrowIdRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowOnCompleteEscrow)
				if err := _Escrow.contract.UnpackLog(event, "OnCompleteEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// EscrowOnCreateEscrowIterator is returned from FilterOnCreateEscrow and is used to iterate over the raw logs and unpacked data for OnCreateEscrow events raised by the Escrow contract.
type EscrowOnCreateEscrowIterator struct {
	Event *EscrowOnCreateEscrow // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowOnCreateEscrowIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowOnCreateEscrow)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowOnCreateEscrow)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowOnCreateEscrowIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowOnCreateEscrowIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowOnCreateEscrow represents a OnCreateEscrow event raised by the Escrow contract.
type EscrowOnCreateEscrow struct {
	Dapp      common.Address
	Client    common.Address
	Provider  common.Address
	Amount    *big.Int
	DaiAmount *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterOnCreateEscrow is a free log retrieval operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_Escrow *EscrowFilterer) FilterOnCreateEscrow(opts *bind.FilterOpts, dapp []common.Address, client []common.Address, provider []common.Address) (*EscrowOnCreateEscrowIterator, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return &EscrowOnCreateEscrowIterator{contract: _Escrow.contract, event: "OnCreateEscrow", logs: logs, sub: sub}, nil
}

// WatchOnCreateEscrow is a free log subscription operation binding the contract event 0x2deff110fb90284ba1ebd12f5a2a449109b5327e5144dcf39bae0fa2fcfa7afb.
//
// Solidity: e OnCreateEscrow(dapp indexed address, client indexed address, provider indexed address, amount uint256, daiAmount uint256)
func (_Escrow *EscrowFilterer) WatchOnCreateEscrow(opts *bind.WatchOpts, sink chan<- *EscrowOnCreateEscrow, dapp []common.Address, client []common.Address, provider []common.Address) (event.Subscription, error) {

	var dappRule []interface{}
	for _, dappItem := range dapp {
		dappRule = append(dappRule, dappItem)
	}
	var clientRule []interface{}
	for _, clientItem := range client {
		clientRule = append(clientRule, clientItem)
	}
	var providerRule []interface{}
	for _, providerItem := range provider {
		providerRule = append(providerRule, providerItem)
	}

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "OnCreateEscrow", dappRule, clientRule, providerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowOnCreateEscrow)
				if err := _Escrow.contract.UnpackLog(event, "OnCreateEscrow", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// EscrowOnInitializeIterator is returned from FilterOnInitialize and is used to iterate over the raw logs and unpacked data for OnInitialize events raised by the Escrow contract.
type EscrowOnInitializeIterator struct {
	Event *EscrowOnInitialize // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *EscrowOnInitializeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(EscrowOnInitialize)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(EscrowOnInitialize)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *EscrowOnInitializeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *EscrowOnInitializeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// EscrowOnInitialize represents a OnInitialize event raised by the Escrow contract.
type EscrowOnInitialize struct {
	Token       common.Address
	DApp        common.Address
	PriceOracle common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterOnInitialize is a free log retrieval operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_Escrow *EscrowFilterer) FilterOnInitialize(opts *bind.FilterOpts, token []common.Address, dApp []common.Address) (*EscrowOnInitializeIterator, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _Escrow.contract.FilterLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return &EscrowOnInitializeIterator{contract: _Escrow.contract, event: "OnInitialize", logs: logs, sub: sub}, nil
}

// WatchOnInitialize is a free log subscription operation binding the contract event 0x92bd6b72cc9afdcca9b04e941a144617e9c12e1b5160a3fb40163fe4a786bff0.
//
// Solidity: e OnInitialize(token indexed address, dApp indexed address, priceOracle address)
func (_Escrow *EscrowFilterer) WatchOnInitialize(opts *bind.WatchOpts, sink chan<- *EscrowOnInitialize, token []common.Address, dApp []common.Address) (event.Subscription, error) {

	var tokenRule []interface{}
	for _, tokenItem := range token {
		tokenRule = append(tokenRule, tokenItem)
	}
	var dAppRule []interface{}
	for _, dAppItem := range dApp {
		dAppRule = append(dAppRule, dAppItem)
	}

	logs, sub, err := _Escrow.contract.WatchLogs(opts, "OnInitialize", tokenRule, dAppRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(EscrowOnInitialize)
				if err := _Escrow.contract.UnpackLog(event, "OnInitialize", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// MigratableABI is the input ABI used to generate the binding from.
const MigratableABI = "[{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"isMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"Migrated\",\"type\":\"event\"}]"

// MigratableBin is the compiled bytecode used for deploying new contracts.
const MigratableBin = `0x608060405234801561001057600080fd5b506101e3806100206000396000f3006080604052600436106100405763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663c0bac1a88114610045575b600080fd5b34801561005157600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526100dc94369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506100f09650505050505050565b604080519115158252519081900360200190f35b600080836040518082805190602001908083835b602083106101235780518252601f199092019160209182019101610104565b51815160209384036101000a6000190180199092169116179052920194855250604051938490038101842086519094879450925082918401908083835b6020831061017f5780518252601f199092019160209182019101610160565b51815160209384036101000a600019018019909216911617905292019485525060405193849003019092205460ff16959450505050505600a165627a7a72305820ffe63abcee9941e159bc152b607835e65ee15e7169d333b79e27e372c86a7cdc0029`

// DeployMigratable deploys a new Ethereum contract, binding an instance of Migratable to it.
func DeployMigratable(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Migratable, error) {
	parsed, err := abi.JSON(strings.NewReader(MigratableABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(MigratableBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Migratable{MigratableCaller: MigratableCaller{contract: contract}, MigratableTransactor: MigratableTransactor{contract: contract}, MigratableFilterer: MigratableFilterer{contract: contract}}, nil
}

// Migratable is an auto generated Go binding around an Ethereum contract.
type Migratable struct {
	MigratableCaller     // Read-only binding to the contract
	MigratableTransactor // Write-only binding to the contract
	MigratableFilterer   // Log filterer for contract events
}

// MigratableCaller is an auto generated read-only Go binding around an Ethereum contract.
type MigratableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MigratableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MigratableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MigratableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MigratableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MigratableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MigratableSession struct {
	Contract     *Migratable       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MigratableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MigratableCallerSession struct {
	Contract *MigratableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// MigratableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MigratableTransactorSession struct {
	Contract     *MigratableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// MigratableRaw is an auto generated low-level Go binding around an Ethereum contract.
type MigratableRaw struct {
	Contract *Migratable // Generic contract binding to access the raw methods on
}

// MigratableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MigratableCallerRaw struct {
	Contract *MigratableCaller // Generic read-only contract binding to access the raw methods on
}

// MigratableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MigratableTransactorRaw struct {
	Contract *MigratableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMigratable creates a new instance of Migratable, bound to a specific deployed contract.
func NewMigratable(address common.Address, backend bind.ContractBackend) (*Migratable, error) {
	contract, err := bindMigratable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Migratable{MigratableCaller: MigratableCaller{contract: contract}, MigratableTransactor: MigratableTransactor{contract: contract}, MigratableFilterer: MigratableFilterer{contract: contract}}, nil
}

// NewMigratableCaller creates a new read-only instance of Migratable, bound to a specific deployed contract.
func NewMigratableCaller(address common.Address, caller bind.ContractCaller) (*MigratableCaller, error) {
	contract, err := bindMigratable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MigratableCaller{contract: contract}, nil
}

// NewMigratableTransactor creates a new write-only instance of Migratable, bound to a specific deployed contract.
func NewMigratableTransactor(address common.Address, transactor bind.ContractTransactor) (*MigratableTransactor, error) {
	contract, err := bindMigratable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MigratableTransactor{contract: contract}, nil
}

// NewMigratableFilterer creates a new log filterer instance of Migratable, bound to a specific deployed contract.
func NewMigratableFilterer(address common.Address, filterer bind.ContractFilterer) (*MigratableFilterer, error) {
	contract, err := bindMigratable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MigratableFilterer{contract: contract}, nil
}

// bindMigratable binds a generic wrapper to an already deployed contract.
func bindMigratable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(MigratableABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Migratable *MigratableRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Migratable.Contract.MigratableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Migratable *MigratableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Migratable.Contract.MigratableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Migratable *MigratableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Migratable.Contract.MigratableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Migratable *MigratableCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Migratable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Migratable *MigratableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Migratable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Migratable *MigratableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Migratable.Contract.contract.Transact(opts, method, params...)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Migratable *MigratableCaller) IsMigrated(opts *bind.CallOpts, contractName string, migrationId string) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Migratable.contract.Call(opts, out, "isMigrated", contractName, migrationId)
	return *ret0, err
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Migratable *MigratableSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _Migratable.Contract.IsMigrated(&_Migratable.CallOpts, contractName, migrationId)
}

// IsMigrated is a free data retrieval call binding the contract method 0xc0bac1a8.
//
// Solidity: function isMigrated(contractName string, migrationId string) constant returns(bool)
func (_Migratable *MigratableCallerSession) IsMigrated(contractName string, migrationId string) (bool, error) {
	return _Migratable.Contract.IsMigrated(&_Migratable.CallOpts, contractName, migrationId)
}

// MigratableMigratedIterator is returned from FilterMigrated and is used to iterate over the raw logs and unpacked data for Migrated events raised by the Migratable contract.
type MigratableMigratedIterator struct {
	Event *MigratableMigrated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MigratableMigratedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MigratableMigrated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MigratableMigrated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MigratableMigratedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MigratableMigratedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MigratableMigrated represents a Migrated event raised by the Migratable contract.
type MigratableMigrated struct {
	ContractName string
	MigrationId  string
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterMigrated is a free log retrieval operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_Migratable *MigratableFilterer) FilterMigrated(opts *bind.FilterOpts) (*MigratableMigratedIterator, error) {

	logs, sub, err := _Migratable.contract.FilterLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return &MigratableMigratedIterator{contract: _Migratable.contract, event: "Migrated", logs: logs, sub: sub}, nil
}

// WatchMigrated is a free log subscription operation binding the contract event 0xdd117a11c22118c9dee4b5a67ce578bc44529dce21ee0ccc439588fbb9fb4ea3.
//
// Solidity: e Migrated(contractName string, migrationId string)
func (_Migratable *MigratableFilterer) WatchMigrated(opts *bind.WatchOpts, sink chan<- *MigratableMigrated) (event.Subscription, error) {

	logs, sub, err := _Migratable.contract.WatchLogs(opts, "Migrated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MigratableMigrated)
				if err := _Migratable.contract.UnpackLog(event, "Migrated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
const SafeMathBin = `0x604c602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f30073000000000000000000000000000000000000000030146080604052600080fd00a165627a7a7230582009c9708e7fd727d237f629c295eaee43be454d48e51d6ab0c97bc63ed295f1b10029`

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}
